name: Security Scans

on:
  workflow_call:
    inputs:
      python_version:
        description: "Python version"
        required: false
        type: string
        default: "3.12"
      requirements_file:
        description: "Path to requirements.txt"
        required: false
        type: string
        default: "requirements.txt"
      working_directory:
        description: "Working directory"
        required: false
        type: string
        default: "."
      run_bandit:
        description: "Run bandit security scan"
        required: false
        type: boolean
        default: true
      run_checkov:
        description: "Run checkov infrastructure security scan"
        required: false
        type: boolean
        default: true
      run_radon:
        description: "Run radon complexity analysis"
        required: false
        type: boolean
        default: false
      upload_reports:
        description: "Upload reports to S3 (requires AWS credentials)"
        required: false
        type: boolean
        default: false
      account_id:
        description: "CloudBot Account ID for S3 uploads (overrides secret)"
        required: false
        type: string
      runner:
        description: "Runner label (default: self-hosted)"
        required: false
        type: string
    secrets:
      gitlab_api_token:
        description: "GitLab API token for private packages"
        required: false
      aws_role_arn:
        description: "AWS IAM role ARN for S3 uploads"
        required: false
      aws_account_id:
        description: "AWS Account ID (for AWS operations, not S3 paths)"
        required: false
      accountid:
        description: "CloudBot Account ID for S3 upload paths"
        required: false

jobs:
  bandit:
    if: inputs.run_bandit
    runs-on: ${{ inputs.runner || 'self-hosted' }}
    env:
      HOME: ${{ github.workspace }}/.home
    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python (for self-hosted runners)
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use system Python or install if needed
          PYTHON_VERSION="${{ inputs.python_version }}"
          PYTHON_MAJOR_MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f1,2)

          # Find available Python
          PYTHON_CMD=""
          if command -v python${PYTHON_MAJOR_MINOR} &> /dev/null; then
            PYTHON_CMD="python${PYTHON_MAJOR_MINOR}"
            echo "Using system Python ${PYTHON_MAJOR_MINOR}"
            $PYTHON_CMD --version
          elif command -v python3 &> /dev/null; then
            PYTHON_CMD="python3"
            SYSTEM_VERSION=$($PYTHON_CMD --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            echo "Using system Python3 (version ${SYSTEM_VERSION})"
            $PYTHON_CMD --version
          else
            echo "Python not found, attempting to install..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3 python3-pip || true
            elif command -v /usr/bin/yum &> /dev/null; then
              sudo /usr/bin/yum install -y python3 python3-pip || true
            fi
            if command -v python3 &> /dev/null; then
              PYTHON_CMD="python3"
              $PYTHON_CMD --version
            else
              echo "Error: Could not find or install Python"
              exit 1
            fi
          fi

          # Install pip if not available
          if ! $PYTHON_CMD -m pip --version &>/dev/null; then
            echo "pip not found, installing..."
            # Try ensurepip first (built-in)
            if ! $PYTHON_CMD -m ensurepip --upgrade --default-pip 2>/dev/null; then
              echo "ensurepip failed, trying get-pip.py..."
              # Download get-pip.py
              /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
              if [ -f /tmp/get-pip.py ]; then
                # Try with --user first (doesn't require root)
                echo "Installing pip with get-pip.py (--user)..."
                $PYTHON_CMD /tmp/get-pip.py --user 2>&1 || true
                # If --user didn't work, try without --user (may require adding to PATH)
                if ! $PYTHON_CMD -m pip --version &>/dev/null; then
                  echo "Installing pip with get-pip.py (system-wide)..."
                  $PYTHON_CMD /tmp/get-pip.py 2>&1 || true
                fi
                # If pip is in user directory, add it to PATH
                if [ -f "$HOME/.local/bin/pip" ]; then
                  echo "$HOME/.local/bin" >> $GITHUB_PATH
                  export PATH="$HOME/.local/bin:$PATH"
                fi
                /bin/rm -f /tmp/get-pip.py
              fi
            fi
            # Try installing via package manager as last resort (non-fatal)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1; then
              echo "Trying package manager as last resort..."
              if command -v /usr/bin/apt-get &> /dev/null; then
                sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              elif command -v /usr/bin/yum &> /dev/null; then
                sudo /usr/bin/yum install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              fi
            fi
            # Verify pip is now available (check both locations)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1 && ! command -v pip &>/dev/null; then
              echo "Error: Failed to install pip. Python: $PYTHON_CMD"
              echo "Attempted: ensurepip, get-pip.py, package manager"
              exit 1
            fi
          fi

          # Add Python to PATH for subsequent steps
          echo "$PYTHON_CMD" >> $GITHUB_PATH || echo "$(which $PYTHON_CMD | xargs dirname)" >> $GITHUB_PATH

          # Create 'python' symlink if it doesn't exist
          if [ "$PYTHON_CMD" != "python" ] && ! command -v python &> /dev/null; then
            /bin/mkdir -p "$HOME/bin"
            /bin/ln -sf $(which $PYTHON_CMD) "$HOME/bin/python" 2>/dev/null || true
            echo "$HOME/bin" >> $GITHUB_PATH
          fi

          # Verify Python and pip are working
          echo "Python location: $(which $PYTHON_CMD)"
          echo "Python version:"
          $PYTHON_CMD --version
          echo "pip version:"
          # Check pip in multiple locations
          if $PYTHON_CMD -m pip --version &>/dev/null; then
            $PYTHON_CMD -m pip --version
          elif [ -f "$HOME/.local/bin/pip" ] && "$HOME/.local/bin/pip" --version &>/dev/null; then
            "$HOME/.local/bin/pip" --version
            echo "Note: pip is installed in ~/.local/bin"
          elif command -v pip &>/dev/null && pip --version &>/dev/null; then
            pip --version
          else
            echo "Warning: Could not verify pip installation"
          fi
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Install dependencies
        working-directory: ${{ inputs.working_directory }}
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use python3 if python doesn't work, fallback to python
          if command -v python3 &> /dev/null && python3 -m pip --version &>/dev/null; then
            PYTHON_CMD="python3"
          elif command -v python &> /dev/null && python -m pip --version &>/dev/null; then
            PYTHON_CMD="python"
          else
            echo "Error: Neither python nor python3 with pip is available"
            exit 1
          fi

          # Create virtual environment to avoid externally-managed-environment error
          VENV_DIR="$HOME/venv"
          echo "Creating virtual environment at $VENV_DIR..."

          # Try to create venv with pip first
          if $PYTHON_CMD -m venv "$VENV_DIR" 2>/dev/null; then
            echo "Virtual environment created with pip"
          # If that fails, try without pip and install pip manually
          elif $PYTHON_CMD -m venv --without-pip "$VENV_DIR" 2>/dev/null; then
            echo "Virtual environment created without pip, installing pip..."
            # Install pip in the venv using get-pip.py
            /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
            if [ -f /tmp/get-pip.py ] && [ -f "$VENV_DIR/bin/python" ]; then
              "$VENV_DIR/bin/python" /tmp/get-pip.py 2>&1 || true
              /bin/rm -f /tmp/get-pip.py
            fi
          # If venv module doesn't work, try installing python3-venv
          else
            echo "venv module not available, trying to install python3-venv..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-venv || true
              # Try again after installing python3-venv
              if $PYTHON_CMD -m venv "$VENV_DIR" 2>/dev/null; then
                echo "Virtual environment created after installing python3-venv"
              elif $PYTHON_CMD -m venv --without-pip "$VENV_DIR" 2>/dev/null; then
                echo "Virtual environment created without pip, installing pip..."
                /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
                if [ -f /tmp/get-pip.py ] && [ -f "$VENV_DIR/bin/python" ]; then
                  "$VENV_DIR/bin/python" /tmp/get-pip.py 2>&1 || true
                  /bin/rm -f /tmp/get-pip.py
                fi
              fi
            fi
          fi

          # Activate virtual environment if it exists and has pip
          if [ -f "$VENV_DIR/bin/activate" ] && [ -f "$VENV_DIR/bin/pip" ]; then
            source "$VENV_DIR/bin/activate"
            echo "$VENV_DIR/bin" >> $GITHUB_PATH
            export PATH="$VENV_DIR/bin:$PATH"
            echo "Virtual environment activated with pip"
            PIP_CMD="pip"
          elif [ -f "$VENV_DIR/bin/activate" ]; then
            # Venv exists but no pip - try to use system pip with --user
            echo "Warning: Virtual environment created but pip not available, using --user flag"
            export PATH="$HOME/.local/bin:$PATH"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
            PIP_CMD="$PYTHON_CMD -m pip"
            PIP_FLAG="--user"
          else
            echo "Warning: Virtual environment not created, using --user flag as fallback"
            export PATH="$HOME/.local/bin:$PATH"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
            PIP_CMD="$PYTHON_CMD -m pip"
            PIP_FLAG="--user"
          fi

          # Upgrade pip in the environment
          if [ "$PIP_CMD" = "pip" ]; then
            pip install --upgrade pip || true
          else
            $PIP_CMD install $PIP_FLAG --upgrade pip || true
          fi

          if [ -f "${{ inputs.requirements_file }}" ]; then
            # Handle GitLab private packages if token provided
            if [ -n "${{ secrets.gitlab_api_token }}" ]; then
              $PIP_CMD install $PIP_FLAG \
                --extra-index-url "https://__token__:${{ secrets.gitlab_api_token }}@gitlab.com/api/v4/projects/71621175/packages/pypi/simple" \
                -r ${{ inputs.requirements_file }}
            else
              $PIP_CMD install $PIP_FLAG -r ${{ inputs.requirements_file }}
            fi
          fi

          # Install bandit (matches GitLab CI)
          $PIP_CMD install $PIP_FLAG --no-cache-dir --upgrade awscli bandit

      - name: Run bandit security scan
        working-directory: ${{ inputs.working_directory }}
        run: |
          echo "=== Running Bandit Security Scan ==="
          # Matches GitLab: -r . -x /tests -f xml -o bandit.xml --exit-zero
          bandit -r . -x /tests -f xml -o bandit.xml --exit-zero || exit 1

      - name: Configure AWS for S3 upload
        if: inputs.upload_reports
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.aws_role_arn }}
          aws-region: us-east-2
          role-session-name: github-actions-security-scans

      - name: Upload bandit report to S3
        if: inputs.upload_reports
        run: |
          DATETIME=$(date +"%Y%m%d-%H%M%S")
          PROJECT_NAME="${{ github.repository }}"
          PROJECT_NAME="${PROJECT_NAME#*/}"
          # Use CloudBot ACCOUNTID (not AWS_ACCOUNT_ID) for S3 paths
          ACCOUNTID="${{ inputs.account_id || secrets.accountid }}"
          if [ -z "$ACCOUNTID" ]; then
            echo "⚠️  Warning: ACCOUNTID not provided, cannot upload to S3"
            exit 0
          fi
          REPORTS_BUCKET="cloudbot-reporting-v2"

          if [ -f "${{ inputs.working_directory }}/bandit.xml" ]; then
            echo "Uploading bandit.xml to S3..."
              aws s3 cp "${{ inputs.working_directory }}/bandit.xml" \
                "s3://${REPORTS_BUCKET}/incoming/${ACCOUNTID}/${PROJECT_NAME}/${DATETIME}-bandit.xml" \
                --region us-east-2 || echo "Warning: Failed to upload bandit.xml"
          fi
        shell: bash

      - name: Upload report as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: bandit-report
          path: ${{ inputs.working_directory }}/bandit.xml
          retention-days: 7

  checkov:
    if: inputs.run_checkov
    runs-on: ${{ inputs.runner || 'self-hosted' }}
    env:
      HOME: ${{ github.workspace }}/.home
    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python (for self-hosted runners)
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use system Python or install if needed
          PYTHON_VERSION="${{ inputs.python_version }}"
          PYTHON_MAJOR_MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f1,2)

          # Find available Python
          PYTHON_CMD=""
          if command -v python${PYTHON_MAJOR_MINOR} &> /dev/null; then
            PYTHON_CMD="python${PYTHON_MAJOR_MINOR}"
            echo "Using system Python ${PYTHON_MAJOR_MINOR}"
            $PYTHON_CMD --version
          elif command -v python3 &> /dev/null; then
            PYTHON_CMD="python3"
            SYSTEM_VERSION=$($PYTHON_CMD --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            echo "Using system Python3 (version ${SYSTEM_VERSION})"
            $PYTHON_CMD --version
          else
            echo "Python not found, attempting to install..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3 python3-pip || true
            elif command -v /usr/bin/yum &> /dev/null; then
              sudo /usr/bin/yum install -y python3 python3-pip || true
            fi
            if command -v python3 &> /dev/null; then
              PYTHON_CMD="python3"
              $PYTHON_CMD --version
            else
              echo "Error: Could not find or install Python"
              exit 1
            fi
          fi

          # Install pip if not available
          if ! $PYTHON_CMD -m pip --version &>/dev/null; then
            echo "pip not found, installing..."
            # Try ensurepip first (built-in)
            if ! $PYTHON_CMD -m ensurepip --upgrade --default-pip 2>/dev/null; then
              echo "ensurepip failed, trying get-pip.py..."
              # Download get-pip.py
              /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
              if [ -f /tmp/get-pip.py ]; then
                # Try with --user first (doesn't require root)
                echo "Installing pip with get-pip.py (--user)..."
                $PYTHON_CMD /tmp/get-pip.py --user 2>&1 || true
                # If --user didn't work, try without --user (may require adding to PATH)
                if ! $PYTHON_CMD -m pip --version &>/dev/null; then
                  echo "Installing pip with get-pip.py (system-wide)..."
                  $PYTHON_CMD /tmp/get-pip.py 2>&1 || true
                fi
                # If pip is in user directory, add it to PATH
                if [ -f "$HOME/.local/bin/pip" ]; then
                  echo "$HOME/.local/bin" >> $GITHUB_PATH
                  export PATH="$HOME/.local/bin:$PATH"
                fi
                /bin/rm -f /tmp/get-pip.py
              fi
            fi
            # Try installing via package manager as last resort (non-fatal)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1; then
              echo "Trying package manager as last resort..."
              if command -v /usr/bin/apt-get &> /dev/null; then
                sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              elif command -v /usr/bin/yum &> /dev/null; then
                sudo /usr/bin/yum install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              fi
            fi
            # Verify pip is now available (check both locations)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1 && ! command -v pip &>/dev/null; then
              echo "Error: Failed to install pip. Python: $PYTHON_CMD"
              echo "Attempted: ensurepip, get-pip.py, package manager"
              exit 1
            fi
          fi

          # Add Python to PATH for subsequent steps
          echo "$PYTHON_CMD" >> $GITHUB_PATH || echo "$(which $PYTHON_CMD | xargs dirname)" >> $GITHUB_PATH

          # Create 'python' symlink if it doesn't exist
          if [ "$PYTHON_CMD" != "python" ] && ! command -v python &> /dev/null; then
            /bin/mkdir -p "$HOME/bin"
            /bin/ln -sf $(which $PYTHON_CMD) "$HOME/bin/python" 2>/dev/null || true
            echo "$HOME/bin" >> $GITHUB_PATH
          fi

          # Verify Python and pip are working
          echo "Python location: $(which $PYTHON_CMD)"
          echo "Python version:"
          $PYTHON_CMD --version
          echo "pip version:"
          # Check pip in multiple locations
          if $PYTHON_CMD -m pip --version &>/dev/null; then
            $PYTHON_CMD -m pip --version
          elif [ -f "$HOME/.local/bin/pip" ] && "$HOME/.local/bin/pip" --version &>/dev/null; then
            "$HOME/.local/bin/pip" --version
            echo "Note: pip is installed in ~/.local/bin"
          elif command -v pip &>/dev/null && pip --version &>/dev/null; then
            pip --version
          else
            echo "Warning: Could not verify pip installation"
          fi
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Install checkov
        run: |
          echo "=== Installing checkov ==="
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use python3 if python doesn't work, fallback to python
          if command -v python3 &> /dev/null && python3 -m pip --version &>/dev/null; then
            PYTHON_CMD="python3"
          elif command -v python &> /dev/null && python -m pip --version &>/dev/null; then
            PYTHON_CMD="python"
          else
            echo "Error: Neither python nor python3 with pip is available"
            exit 1
          fi

          # Create virtual environment to avoid externally-managed-environment error
          VENV_DIR="$HOME/venv"
          echo "Creating virtual environment at $VENV_DIR..."

          # Try to create venv with pip first
          if $PYTHON_CMD -m venv "$VENV_DIR" 2>/dev/null; then
            echo "Virtual environment created with pip"
          # If that fails, try without pip and install pip manually
          elif $PYTHON_CMD -m venv --without-pip "$VENV_DIR" 2>/dev/null; then
            echo "Virtual environment created without pip, installing pip..."
            # Install pip in the venv using get-pip.py
            /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
            if [ -f /tmp/get-pip.py ] && [ -f "$VENV_DIR/bin/python" ]; then
              "$VENV_DIR/bin/python" /tmp/get-pip.py 2>&1 || true
              /bin/rm -f /tmp/get-pip.py
            fi
          # If venv module doesn't work, try installing python3-venv
          else
            echo "venv module not available, trying to install python3-venv..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-venv || true
              # Try again after installing python3-venv
              if $PYTHON_CMD -m venv "$VENV_DIR" 2>/dev/null; then
                echo "Virtual environment created after installing python3-venv"
              elif $PYTHON_CMD -m venv --without-pip "$VENV_DIR" 2>/dev/null; then
                echo "Virtual environment created without pip, installing pip..."
                /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
                if [ -f /tmp/get-pip.py ] && [ -f "$VENV_DIR/bin/python" ]; then
                  "$VENV_DIR/bin/python" /tmp/get-pip.py 2>&1 || true
                  /bin/rm -f /tmp/get-pip.py
                fi
              fi
            fi
          fi

          # Activate virtual environment if it exists and has pip
          if [ -f "$VENV_DIR/bin/activate" ] && [ -f "$VENV_DIR/bin/pip" ]; then
            source "$VENV_DIR/bin/activate"
            echo "$VENV_DIR/bin" >> $GITHUB_PATH
            export PATH="$VENV_DIR/bin:$PATH"
            echo "Virtual environment activated with pip"
            PIP_CMD="pip"
          elif [ -f "$VENV_DIR/bin/activate" ]; then
            # Venv exists but no pip - try to use system pip with --user
            echo "Warning: Virtual environment created but pip not available, using --user flag"
            export PATH="$HOME/.local/bin:$PATH"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
            PIP_CMD="$PYTHON_CMD -m pip"
            PIP_FLAG="--user"
          else
            echo "Warning: Virtual environment not created, using --user flag as fallback"
            export PATH="$HOME/.local/bin:$PATH"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
            PIP_CMD="$PYTHON_CMD -m pip"
            PIP_FLAG="--user"
          fi

          # Upgrade pip in the environment
          if [ "$PIP_CMD" = "pip" ]; then
            pip install --upgrade pip || true
          else
            $PIP_CMD install $PIP_FLAG --upgrade pip || true
          fi

          # Install checkov using pip (avoids GLIBC compatibility issues)
          echo "Installing checkov..."
          $PIP_CMD install $PIP_FLAG checkov

          # Verify installation
          checkov --version || (echo "Error: checkov installation failed" && exit 1)
          echo "✅ checkov successfully installed"
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Run checkov security scan
        working-directory: ${{ inputs.working_directory }}
        run: |
          echo "=== Running Checkov Security Scan ==="
          # Matches GitLab: --skip-check with same checks, --soft-fail, -o cli -o junitxml
          checkov --directory . \
            --skip-check CKV2_AWS_5,CKV2_AWS_29,CKV2_AWS_51,CKV2_AWS_53,CKV_AWS_76,CKV_AWS_115,CKV_AWS_119,CKV_AWS_120,CKV_AWS_158,CKV_AWS_173,CKV_AWS_225,CKV_AWS_237,CKV_AWS_338,CKV_TF_1,CKV_GITLABCI_2 \
            --soft-fail \
            -o cli \
            -o junitxml \
            --output-file-path console,checkov.xml || exit 1

      - name: Configure AWS for S3 upload
        if: inputs.upload_reports
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.aws_role_arn }}
          aws-region: us-east-2
          role-session-name: github-actions-security-scans

      - name: Upload checkov report to S3
        if: inputs.upload_reports
        run: |
          DATETIME=$(date +"%Y%m%d-%H%M%S")
          PROJECT_NAME="${{ github.repository }}"
          PROJECT_NAME="${PROJECT_NAME#*/}"
          # Use CloudBot ACCOUNTID (not AWS_ACCOUNT_ID) for S3 paths
          ACCOUNTID="${{ inputs.account_id || secrets.accountid }}"
          if [ -z "$ACCOUNTID" ]; then
            echo "⚠️  Warning: ACCOUNTID not provided, cannot upload to S3"
            exit 0
          fi
          REPORTS_BUCKET="cloudbot-reporting-v2"

          if [ -f "${{ inputs.working_directory }}/checkov.xml" ]; then
            echo "Uploading checkov.xml to S3..."
            aws s3 cp "${{ inputs.working_directory }}/checkov.xml" \
              "s3://${REPORTS_BUCKET}/incoming/${ACCOUNTID}/${PROJECT_NAME}/${DATETIME}-checkov.xml" \
              --region us-east-2 || echo "Warning: Failed to upload checkov.xml"
          fi
        shell: bash

      - name: Upload report as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: checkov-report
          path: ${{ inputs.working_directory }}/checkov.xml
          retention-days: 7

  radon:
    if: inputs.run_radon
    runs-on: ${{ inputs.runner || 'self-hosted' }}
    env:
      HOME: ${{ github.workspace }}/.home
    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python (for self-hosted runners)
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use system Python or install if needed
          PYTHON_VERSION="${{ inputs.python_version }}"
          PYTHON_MAJOR_MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f1,2)

          # Find available Python
          PYTHON_CMD=""
          if command -v python${PYTHON_MAJOR_MINOR} &> /dev/null; then
            PYTHON_CMD="python${PYTHON_MAJOR_MINOR}"
            echo "Using system Python ${PYTHON_MAJOR_MINOR}"
            $PYTHON_CMD --version
          elif command -v python3 &> /dev/null; then
            PYTHON_CMD="python3"
            SYSTEM_VERSION=$($PYTHON_CMD --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            echo "Using system Python3 (version ${SYSTEM_VERSION})"
            $PYTHON_CMD --version
          else
            echo "Python not found, attempting to install..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3 python3-pip || true
            elif command -v /usr/bin/yum &> /dev/null; then
              sudo /usr/bin/yum install -y python3 python3-pip || true
            fi
            if command -v python3 &> /dev/null; then
              PYTHON_CMD="python3"
              $PYTHON_CMD --version
            else
              echo "Error: Could not find or install Python"
              exit 1
            fi
          fi

          # Install pip if not available
          if ! $PYTHON_CMD -m pip --version &>/dev/null; then
            echo "pip not found, installing..."
            # Try ensurepip first (built-in)
            if ! $PYTHON_CMD -m ensurepip --upgrade --default-pip 2>/dev/null; then
              echo "ensurepip failed, trying get-pip.py..."
              # Download get-pip.py
              /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
              if [ -f /tmp/get-pip.py ]; then
                # Try with --user first (doesn't require root)
                echo "Installing pip with get-pip.py (--user)..."
                $PYTHON_CMD /tmp/get-pip.py --user 2>&1 || true
                # If --user didn't work, try without --user (may require adding to PATH)
                if ! $PYTHON_CMD -m pip --version &>/dev/null; then
                  echo "Installing pip with get-pip.py (system-wide)..."
                  $PYTHON_CMD /tmp/get-pip.py 2>&1 || true
                fi
                # If pip is in user directory, add it to PATH
                if [ -f "$HOME/.local/bin/pip" ]; then
                  echo "$HOME/.local/bin" >> $GITHUB_PATH
                  export PATH="$HOME/.local/bin:$PATH"
                fi
                /bin/rm -f /tmp/get-pip.py
              fi
            fi
            # Try installing via package manager as last resort (non-fatal)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1; then
              echo "Trying package manager as last resort..."
              if command -v /usr/bin/apt-get &> /dev/null; then
                sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              elif command -v /usr/bin/yum &> /dev/null; then
                sudo /usr/bin/yum install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              fi
            fi
            # Verify pip is now available (check both locations)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1 && ! command -v pip &>/dev/null; then
              echo "Error: Failed to install pip. Python: $PYTHON_CMD"
              echo "Attempted: ensurepip, get-pip.py, package manager"
              exit 1
            fi
          fi

          # Add Python to PATH for subsequent steps
          echo "$PYTHON_CMD" >> $GITHUB_PATH || echo "$(which $PYTHON_CMD | xargs dirname)" >> $GITHUB_PATH

          # Create 'python' symlink if it doesn't exist
          if [ "$PYTHON_CMD" != "python" ] && ! command -v python &> /dev/null; then
            /bin/mkdir -p "$HOME/bin"
            /bin/ln -sf $(which $PYTHON_CMD) "$HOME/bin/python" 2>/dev/null || true
            echo "$HOME/bin" >> $GITHUB_PATH
          fi

          # Verify Python and pip are working
          echo "Python location: $(which $PYTHON_CMD)"
          echo "Python version:"
          $PYTHON_CMD --version
          echo "pip version:"
          # Check pip in multiple locations
          if $PYTHON_CMD -m pip --version &>/dev/null; then
            $PYTHON_CMD -m pip --version
          elif [ -f "$HOME/.local/bin/pip" ] && "$HOME/.local/bin/pip" --version &>/dev/null; then
            "$HOME/.local/bin/pip" --version
            echo "Note: pip is installed in ~/.local/bin"
          elif command -v pip &>/dev/null && pip --version &>/dev/null; then
            pip --version
          else
            echo "Warning: Could not verify pip installation"
          fi
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Install dependencies
        working-directory: ${{ inputs.working_directory }}
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use python3 if python doesn't work, fallback to python
          if command -v python3 &> /dev/null && python3 -m pip --version &>/dev/null; then
            PYTHON_CMD="python3"
          elif command -v python &> /dev/null && python -m pip --version &>/dev/null; then
            PYTHON_CMD="python"
          else
            echo "Error: Neither python nor python3 with pip is available"
            exit 1
          fi

          # Create virtual environment to avoid externally-managed-environment error
          VENV_DIR="$HOME/venv"
          echo "Creating virtual environment at $VENV_DIR..."

          # Try to create venv with pip first
          if $PYTHON_CMD -m venv "$VENV_DIR" 2>/dev/null; then
            echo "Virtual environment created with pip"
          # If that fails, try without pip and install pip manually
          elif $PYTHON_CMD -m venv --without-pip "$VENV_DIR" 2>/dev/null; then
            echo "Virtual environment created without pip, installing pip..."
            # Install pip in the venv using get-pip.py
            /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
            if [ -f /tmp/get-pip.py ] && [ -f "$VENV_DIR/bin/python" ]; then
              "$VENV_DIR/bin/python" /tmp/get-pip.py 2>&1 || true
              /bin/rm -f /tmp/get-pip.py
            fi
          # If venv module doesn't work, try installing python3-venv
          else
            echo "venv module not available, trying to install python3-venv..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-venv || true
              # Try again after installing python3-venv
              if $PYTHON_CMD -m venv "$VENV_DIR" 2>/dev/null; then
                echo "Virtual environment created after installing python3-venv"
              elif $PYTHON_CMD -m venv --without-pip "$VENV_DIR" 2>/dev/null; then
                echo "Virtual environment created without pip, installing pip..."
                /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
                if [ -f /tmp/get-pip.py ] && [ -f "$VENV_DIR/bin/python" ]; then
                  "$VENV_DIR/bin/python" /tmp/get-pip.py 2>&1 || true
                  /bin/rm -f /tmp/get-pip.py
                fi
              fi
            fi
          fi

          # Activate virtual environment if it exists and has pip
          if [ -f "$VENV_DIR/bin/activate" ] && [ -f "$VENV_DIR/bin/pip" ]; then
            source "$VENV_DIR/bin/activate"
            echo "$VENV_DIR/bin" >> $GITHUB_PATH
            export PATH="$VENV_DIR/bin:$PATH"
            echo "Virtual environment activated with pip"
            PIP_CMD="pip"
          elif [ -f "$VENV_DIR/bin/activate" ]; then
            # Venv exists but no pip - try to use system pip with --user
            echo "Warning: Virtual environment created but pip not available, using --user flag"
            export PATH="$HOME/.local/bin:$PATH"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
            PIP_CMD="$PYTHON_CMD -m pip"
            PIP_FLAG="--user"
          else
            echo "Warning: Virtual environment not created, using --user flag as fallback"
            export PATH="$HOME/.local/bin:$PATH"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
            PIP_CMD="$PYTHON_CMD -m pip"
            PIP_FLAG="--user"
          fi

          # Upgrade pip in the environment
          if [ "$PIP_CMD" = "pip" ]; then
            pip install --upgrade pip || true
          else
            $PIP_CMD install $PIP_FLAG --upgrade pip || true
          fi

          if [ -f "${{ inputs.requirements_file }}" ]; then
            # Handle GitLab private packages if token provided
            if [ -n "${{ secrets.gitlab_api_token }}" ]; then
              $PIP_CMD install $PIP_FLAG \
                --extra-index-url "https://__token__:${{ secrets.gitlab_api_token }}@gitlab.com/api/v4/projects/71621175/packages/pypi/simple" \
                -r ${{ inputs.requirements_file }}
            else
              $PIP_CMD install $PIP_FLAG -r ${{ inputs.requirements_file }}
            fi
          fi

          # Install radon and awscli (matches GitLab CI)
          $PIP_CMD install $PIP_FLAG --no-cache-dir --upgrade awscli radon

      - name: Run radon complexity analysis
        working-directory: ${{ inputs.working_directory }}
        run: |
          echo "=== Running Radon Complexity Analysis ==="
          # Matches GitLab: -i "tests" . -s
          radon cc -i "tests" . -s --xml -O radon-cc.xml || exit 1
          radon mi -i "tests" . -s -j -O radon-mi.json || exit 1
          radon raw -i "tests" . -j -O radon-raw.json || exit 1

      - name: Configure AWS for S3 upload
        if: inputs.upload_reports
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.aws_role_arn }}
          aws-region: us-east-2
          role-session-name: github-actions-security-scans

      - name: Upload radon reports to S3
        if: inputs.upload_reports
        run: |
          DATETIME=$(date +"%Y%m%d-%H%M%S")
          PROJECT_NAME="${{ github.repository }}"
          PROJECT_NAME="${PROJECT_NAME#*/}"
          # Use CloudBot ACCOUNTID (not AWS_ACCOUNT_ID) for S3 paths
          ACCOUNTID="${{ inputs.account_id || secrets.accountid }}"
          if [ -z "$ACCOUNTID" ]; then
            echo "⚠️  Warning: ACCOUNTID not provided, cannot upload to S3"
            exit 0
          fi
          REPORTS_BUCKET="cloudbot-reporting-v2"

          for report in radon-cc.xml radon-mi.json radon-raw.json; do
            if [ -f "${{ inputs.working_directory }}/${report}" ]; then
              echo "Uploading ${report} to S3..."
              aws s3 cp "${{ inputs.working_directory }}/${report}" \
                "s3://${REPORTS_BUCKET}/incoming/${ACCOUNTID}/${PROJECT_NAME}/${DATETIME}-${report}" \
                --region us-east-2 || echo "Warning: Failed to upload ${report}"
            fi
          done
        shell: bash

      - name: Upload reports as artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: radon-reports
          path: |
            ${{ inputs.working_directory }}/radon-cc.xml
            ${{ inputs.working_directory }}/radon-mi.json
            ${{ inputs.working_directory }}/radon-raw.json
          retention-days: 7
