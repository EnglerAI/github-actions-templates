name: Python Test

on:
  workflow_call:
    inputs:
      python_version:
        description: "Python version"
        required: false
        type: string
        default: "3.12"
      requirements_file:
        description: "Path to requirements.txt"
        required: false
        type: string
        default: "requirements.txt"
      working_directory:
        description: "Working directory"
        required: false
        type: string
        default: "."
      coverage_threshold:
        description: "Minimum code coverage percentage"
        required: false
        type: number
        default: 0
      upload_reports:
        description: "Upload reports to S3 (requires AWS credentials)"
        required: false
        type: boolean
        default: false
      account_id:
        description: "CloudBot Account ID for S3 uploads (overrides secret)"
        required: false
        type: string
      runner:
        description: "Runner label (default: self-hosted)"
        required: false
        type: string
    secrets:
      gitlab_api_token:
        description: "GitLab API token for private packages"
        required: false
      aws_role_arn:
        description: "AWS IAM role ARN for S3 uploads"
        required: false
      aws_account_id:
        description: "AWS Account ID (for AWS operations, not S3 paths)"
        required: false
      accountid:
        description: "CloudBot Account ID for S3 upload paths"
        required: false

jobs:
  lint:
    runs-on: ${{ inputs.runner || 'self-hosted' }}
    env:
      HOME: ${{ github.workspace }}/.home
    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python (for self-hosted runners)
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use system Python or install if needed
          PYTHON_VERSION="${{ inputs.python_version }}"
          PYTHON_MAJOR_MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f1,2)

          # Find available Python
          PYTHON_CMD=""
          if command -v python${PYTHON_MAJOR_MINOR} &> /dev/null; then
            PYTHON_CMD="python${PYTHON_MAJOR_MINOR}"
            echo "Using system Python ${PYTHON_MAJOR_MINOR}"
            $PYTHON_CMD --version
          elif command -v python3 &> /dev/null; then
            PYTHON_CMD="python3"
            SYSTEM_VERSION=$($PYTHON_CMD --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            echo "Using system Python3 (version ${SYSTEM_VERSION})"
            $PYTHON_CMD --version
          else
            echo "Python not found, attempting to install..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3 python3-pip || true
            elif command -v /usr/bin/yum &> /dev/null; then
              sudo /usr/bin/yum install -y python3 python3-pip || true
            fi
            if command -v python3 &> /dev/null; then
              PYTHON_CMD="python3"
              $PYTHON_CMD --version
            else
              echo "Error: Could not find or install Python"
              exit 1
            fi
          fi

          # Install pip if not available
          if ! $PYTHON_CMD -m pip --version &>/dev/null; then
            echo "pip not found, installing..."
            # Try ensurepip first (built-in)
            $PYTHON_CMD -m ensurepip --upgrade --default-pip 2>/dev/null || true
            # If that fails, try get-pip.py
            if ! $PYTHON_CMD -m pip --version &>/dev/null; then
              /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py
              $PYTHON_CMD /tmp/get-pip.py --user 2>/dev/null || $PYTHON_CMD /tmp/get-pip.py 2>/dev/null || true
              /bin/rm -f /tmp/get-pip.py
            fi
            # Try installing via package manager as last resort
            if ! $PYTHON_CMD -m pip --version &>/dev/null; then
              if command -v /usr/bin/apt-get &> /dev/null; then
                sudo /usr/bin/apt-get install -y python3-pip || true
              elif command -v /usr/bin/yum &> /dev/null; then
                sudo /usr/bin/yum install -y python3-pip || true
              fi
            fi
            # Verify pip is now available
            if ! $PYTHON_CMD -m pip --version &>/dev/null; then
              echo "Error: Failed to install pip"
              exit 1
            fi
          fi

          # Add Python to PATH for subsequent steps
          echo "$PYTHON_CMD" >> $GITHUB_PATH || echo "$(which $PYTHON_CMD | xargs dirname)" >> $GITHUB_PATH

          # Create 'python' symlink if it doesn't exist
          if [ "$PYTHON_CMD" != "python" ] && ! command -v python &> /dev/null; then
            /bin/mkdir -p "$HOME/bin"
            /bin/ln -sf $(which $PYTHON_CMD) "$HOME/bin/python" 2>/dev/null || true
            echo "$HOME/bin" >> $GITHUB_PATH
          fi

          # Verify Python and pip are working
          echo "Python location: $(which $PYTHON_CMD)"
          echo "Python version:"
          $PYTHON_CMD --version
          echo "pip version:"
          $PYTHON_CMD -m pip --version
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Install dependencies
        working-directory: ${{ inputs.working_directory }}
        run: |
          python -m pip install --upgrade pip

          if [ -f "${{ inputs.requirements_file }}" ]; then
            # Handle GitLab private packages if token provided
            if [ -n "${{ secrets.gitlab_api_token }}" ]; then
              echo "Installing with GitLab private package access..."
              pip install \
                --extra-index-url "https://__token__:${{ secrets.gitlab_api_token }}@gitlab.com/api/v4/projects/71621175/packages/pypi/simple" \
                -r ${{ inputs.requirements_file }}
            else
              pip install -r ${{ inputs.requirements_file }}
            fi
          fi

          # Install linting tools
          pip install flake8 flake8-docstrings mypy

      - name: Lint with flake8
        working-directory: ${{ inputs.working_directory }}
        run: |
          # Stop the build if there are Python syntax errors or undefined names
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude=test*.py

          # Exit-zero treats all errors as warnings
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics \
            --extend-exclude=test*.py --extend-ignore=D

      - name: Type check with mypy
        working-directory: ${{ inputs.working_directory }}
        run: |
          mypy . --exclude 'test_.*.py$' \
            --ignore-missing-imports \
            --no-strict-optional \
            --allow-untyped-calls \
            --allow-untyped-defs
        continue-on-error: true

  test:
    runs-on: ${{ inputs.runner || 'self-hosted' }}
    env:
      HOME: ${{ github.workspace }}/.home
    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python (for self-hosted runners)
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use system Python or install if needed
          PYTHON_VERSION="${{ inputs.python_version }}"
          PYTHON_MAJOR_MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f1,2)

          # Find available Python
          PYTHON_CMD=""
          if command -v python${PYTHON_MAJOR_MINOR} &> /dev/null; then
            PYTHON_CMD="python${PYTHON_MAJOR_MINOR}"
            echo "Using system Python ${PYTHON_MAJOR_MINOR}"
            $PYTHON_CMD --version
          elif command -v python3 &> /dev/null; then
            PYTHON_CMD="python3"
            SYSTEM_VERSION=$($PYTHON_CMD --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            echo "Using system Python3 (version ${SYSTEM_VERSION})"
            $PYTHON_CMD --version
          else
            echo "Python not found, attempting to install..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3 python3-pip || true
            elif command -v /usr/bin/yum &> /dev/null; then
              sudo /usr/bin/yum install -y python3 python3-pip || true
            fi
            if command -v python3 &> /dev/null; then
              PYTHON_CMD="python3"
              $PYTHON_CMD --version
            else
              echo "Error: Could not find or install Python"
              exit 1
            fi
          fi

          # Install pip if not available
          if ! $PYTHON_CMD -m pip --version &>/dev/null; then
            echo "pip not found, installing..."
            # Try ensurepip first (built-in)
            $PYTHON_CMD -m ensurepip --upgrade --default-pip 2>/dev/null || true
            # If that fails, try get-pip.py
            if ! $PYTHON_CMD -m pip --version &>/dev/null; then
              /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py
              $PYTHON_CMD /tmp/get-pip.py --user 2>/dev/null || $PYTHON_CMD /tmp/get-pip.py 2>/dev/null || true
              /bin/rm -f /tmp/get-pip.py
            fi
            # Try installing via package manager as last resort
            if ! $PYTHON_CMD -m pip --version &>/dev/null; then
              if command -v /usr/bin/apt-get &> /dev/null; then
                sudo /usr/bin/apt-get install -y python3-pip || true
              elif command -v /usr/bin/yum &> /dev/null; then
                sudo /usr/bin/yum install -y python3-pip || true
              fi
            fi
            # Verify pip is now available
            if ! $PYTHON_CMD -m pip --version &>/dev/null; then
              echo "Error: Failed to install pip"
              exit 1
            fi
          fi

          # Add Python to PATH for subsequent steps
          echo "$PYTHON_CMD" >> $GITHUB_PATH || echo "$(which $PYTHON_CMD | xargs dirname)" >> $GITHUB_PATH

          # Create 'python' symlink if it doesn't exist
          if [ "$PYTHON_CMD" != "python" ] && ! command -v python &> /dev/null; then
            /bin/mkdir -p "$HOME/bin"
            /bin/ln -sf $(which $PYTHON_CMD) "$HOME/bin/python" 2>/dev/null || true
            echo "$HOME/bin" >> $GITHUB_PATH
          fi

          # Verify Python and pip are working
          echo "Python location: $(which $PYTHON_CMD)"
          echo "Python version:"
          $PYTHON_CMD --version
          echo "pip version:"
          $PYTHON_CMD -m pip --version
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Install dependencies
        working-directory: ${{ inputs.working_directory }}
        run: |
          python -m pip install --upgrade pip

          if [ -f "${{ inputs.requirements_file }}" ]; then
            # Handle GitLab private packages if token provided
            if [ -n "${{ secrets.gitlab_api_token }}" ]; then
              echo "Installing with GitLab private package access..."
              pip install \
                --extra-index-url "https://__token__:${{ secrets.gitlab_api_token }}@gitlab.com/api/v4/projects/71621175/packages/pypi/simple" \
                -r ${{ inputs.requirements_file }}
            else
              pip install -r ${{ inputs.requirements_file }}
            fi
          fi

          # Install test dependencies
          pip install pytest pytest-cov pytest-mock pytest-custom_exit_code moto coverage

      - name: Run tests with pytest
        working-directory: ${{ inputs.working_directory }}
        run: |
          # Check for test files in tests/ directory
          HAS_TESTS_DIR=false
          if [ -d "tests" ] && find tests -name "test_*.py" | grep -q .; then
            HAS_TESTS_DIR=true
          fi

          # Check for test files in current directory
          HAS_CURRENT_DIR_TESTS=false
          if find . -maxdepth 1 -name "test_*.py" | grep -q .; then
            HAS_CURRENT_DIR_TESTS=true
          fi

          if [ "$HAS_TESTS_DIR" = true ] || [ "$HAS_CURRENT_DIR_TESTS" = true ]; then
            echo "Running pytest with coverage..."
            
            # Determine pytest target based on where tests are found
            if [ "$HAS_TESTS_DIR" = true ] && [ "$HAS_CURRENT_DIR_TESTS" = true ]; then
              # Both locations have tests - run pytest on current directory (will find both)
              PYTEST_TARGET="."
            elif [ "$HAS_TESTS_DIR" = true ]; then
              # Only tests/ directory has tests
              PYTEST_TARGET="tests/"
            else
              # Only current directory has tests
              PYTEST_TARGET="."
            fi
            
            # Create .coveragerc to exclude test files from coverage
            # Since we're in the working directory, create it here
            echo "[run]" > .coveragerc
            echo "omit = " >> .coveragerc
            echo "    test_*.py" >> .coveragerc
            echo "    */test_*.py" >> .coveragerc
            echo "    tests/*" >> .coveragerc
            echo "    */tests/*" >> .coveragerc
            
            echo "Running pytest on: $PYTEST_TARGET"
            pytest $PYTEST_TARGET -v \
              --cov=. \
              --cov-config=.coveragerc \
              --cov-report=term-missing \
              --cov-report=xml \
              --cov-report=html \
              --junitxml=pytest-report.xml \
              --suppress-tests-failed-exit-code
            
            # Store exit code but don't fail yet
            PYTEST_EXIT=$?
            
            echo "pytest_exit_code=${PYTEST_EXIT}" >> $GITHUB_ENV
          else
            echo "No tests directory found or no test files, skipping tests"
            echo "pytest_exit_code=0" >> $GITHUB_ENV
          fi

      - name: Check coverage threshold
        if: inputs.coverage_threshold > 0
        working-directory: ${{ inputs.working_directory }}
        run: |
          if [ -f "coverage.xml" ]; then
            # Extract coverage percentage from coverage.xml
            COVERAGE=$(python -c "
            import xml.etree.ElementTree as ET
            tree = ET.parse('coverage.xml')
            root = tree.getroot()
            line_rate = float(root.get('line-rate', 0))
            print(f'{line_rate * 100:.2f}')
            " || echo "0")
            
            echo "Coverage: ${COVERAGE}%"
            echo "Threshold: ${{ inputs.coverage_threshold }}%"
            
            # Compare coverage to threshold
            if (( $(echo "${COVERAGE} < ${{ inputs.coverage_threshold }}" | bc -l) )); then
              echo "âŒ Coverage ${COVERAGE}% is below threshold ${{ inputs.coverage_threshold }}%"
              exit 1
            else
              echo "âœ… Coverage ${COVERAGE}% meets threshold ${{ inputs.coverage_threshold }}%"
            fi
          else
            echo "No coverage.xml found, skipping threshold check"
          fi

      - name: Configure AWS for S3 upload
        if: inputs.upload_reports
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.aws_role_arn }}
          aws-region: us-east-2
          role-session-name: github-actions-python-test

      - name: Upload test reports to S3
        if: inputs.upload_reports && always()
        run: |
          DATETIME=$(date +"%Y%m%d-%H%M%S")
          PROJECT_NAME="${{ github.repository }}"
          PROJECT_NAME="${PROJECT_NAME#*/}"
          # Use CloudBot ACCOUNTID (not AWS_ACCOUNT_ID) for S3 paths
          ACCOUNTID="${{ inputs.account_id || secrets.accountid }}"
          if [ -z "$ACCOUNTID" ]; then
            echo "âš ï¸  Warning: ACCOUNTID not provided, cannot upload to S3"
            exit 0
          fi
          REPORTS_BUCKET="cloudbot-reporting-v2"

          if [ -f "${{ inputs.working_directory }}/pytest-report.xml" ]; then
            echo "Uploading pytest-report.xml to S3..."
            aws s3 cp "${{ inputs.working_directory }}/pytest-report.xml" \
              "s3://${REPORTS_BUCKET}/incoming/${ACCOUNTID}/${PROJECT_NAME}/${DATETIME}-report.xml" \
              --region us-east-2 || echo "Warning: Failed to upload report.xml"
          fi

          if [ -f "${{ inputs.working_directory }}/coverage.xml" ]; then
            echo "Uploading coverage.xml to S3..."
            aws s3 cp "${{ inputs.working_directory }}/coverage.xml" \
              "s3://${REPORTS_BUCKET}/incoming/${ACCOUNTID}/${PROJECT_NAME}/${DATETIME}-coverage.xml" \
              --region us-east-2 || echo "Warning: Failed to upload coverage.xml"
          fi
        shell: bash

      - name: Upload test results as artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ inputs.python_version }}
          path: |
            ${{ inputs.working_directory }}/pytest-report.xml
            ${{ inputs.working_directory }}/coverage.xml
            ${{ inputs.working_directory }}/htmlcov/
          retention-days: 30

      - name: Upload coverage to Codecov
        if: always()
        uses: codecov/codecov-action@v4
        with:
          files: ${{ inputs.working_directory }}/coverage.xml
          flags: unittests
          name: codecov-${{ inputs.python_version }}
        continue-on-error: true

      - name: Comment on PR with test results
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const workingDir = '${{ inputs.working_directory }}';

            let coverage = 'N/A';
            let tests = 'N/A';
            let passed = 'N/A';
            let failed = 'N/A';
            let skipped = 'N/A';

            // Parse coverage.xml
            try {
              const coverageXml = fs.readFileSync(path.join(workingDir, 'coverage.xml'), 'utf8');
              const match = coverageXml.match(/line-rate="([0-9.]+)"/);
              if (match) {
                coverage = (parseFloat(match[1]) * 100).toFixed(2) + '%';
              }
            } catch (err) {
              console.log('Could not read coverage file');
            }

            // Parse pytest-report.xml (JUnit XML format)
            try {
              // Helper function to parse XML content
              function parsePytestXml(xmlContent) {
                // Use more flexible regex patterns to extract attributes (order-independent)
                const testsMatch = xmlContent.match(/tests="(\d+)"/);
                const failuresMatch = xmlContent.match(/failures="(\d+)"/);
                const errorsMatch = xmlContent.match(/errors="(\d+)"/);
                const skippedMatch = xmlContent.match(/skipped="(\d+)"/);
                
                if (testsMatch) {
                  const total = parseInt(testsMatch[1], 10);
                  const failures = failuresMatch ? parseInt(failuresMatch[1], 10) : 0;
                  const errors = errorsMatch ? parseInt(errorsMatch[1], 10) : 0;
                  const skippedCount = skippedMatch ? parseInt(skippedMatch[1], 10) : 0;
                  const passedCount = total - failures - errors - skippedCount;
                  
                  tests = total.toString();
                  passed = passedCount.toString();
                  failed = (failures + errors).toString();
                  skipped = skippedCount.toString();
                  
                  console.log(`Parsed test results: ${total} total, ${passedCount} passed, ${failures + errors} failed, ${skippedCount} skipped`);
                  return true;
                } else {
                  console.log('Could not find tests attribute in pytest-report.xml');
                  console.log('File preview:', xmlContent.substring(0, 500));
                  return false;
                }
              }
              
              const reportPath = path.join(workingDir, 'pytest-report.xml');
              console.log(`Looking for pytest report at: ${reportPath}`);
              
              // Check if file exists in working directory
              if (fs.existsSync(reportPath)) {
                const pytestXml = fs.readFileSync(reportPath, 'utf8');
                parsePytestXml(pytestXml);
              } else {
                console.log(`File not found: ${reportPath}`);
                // Try root directory as fallback
                const rootPath = 'pytest-report.xml';
                if (fs.existsSync(rootPath)) {
                  console.log(`Found report at root: ${rootPath}`);
                  const pytestXml = fs.readFileSync(rootPath, 'utf8');
                  parsePytestXml(pytestXml);
                } else {
                  console.log('pytest-report.xml not found in working directory or root');
                }
              }
            } catch (err) {
              console.log('Could not read pytest report file:', err.message);
              console.log('Error details:', err.stack);
            }

            const output = `## ðŸ§ª Python Tests

            **Python Version:** \`${{ inputs.python_version }}\`
            **Coverage:** \`${coverage}\` (excluding test files)
            **Status:** \`${{ job.status }}\`

            **Test Results:**
            - âœ… **Passing:** ${passed}
            - âŒ **Failing:** ${failed}
            - â­ï¸ **Skipped:** ${skipped}
            - ðŸ“Š **Total:** ${tests}

            *View detailed results in the Actions tab*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });
