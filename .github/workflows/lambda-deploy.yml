name: Lambda Deploy

on:
  workflow_call:
    inputs:
      function_name:
        description: "Name of Lambda function (required)"
        required: true
        type: string
      stack_name:
        description: "CloudFormation stack name (defaults to function_name-stack)"
        required: false
        type: string
      environment:
        description: "Target environment (dev/qat/stg/prd)"
        required: true
        type: string
      aws_region:
        description: "AWS region"
        required: true
        type: string
        default: "us-east-2"
      python_version:
        description: "Python version"
        required: false
        type: string
        default: "3.12"
      sam_template:
        description: "Path to SAM template file"
        required: false
        type: string
        default: "template.yml"
      requirements_file:
        description: "Path to requirements.txt"
        required: false
        type: string
        default: "requirements.txt"
      run_tests:
        description: "Run tests before deployment"
        required: false
        type: boolean
        default: true
      verify_s3_permissions:
        description: "Verify S3 permissions before upload (recommended)"
        required: false
        type: boolean
        default: true
      kms_key_alias:
        description: "KMS key alias for S3 encryption"
        required: false
        type: string
        default: "alias/CloudBotPipelineKey"
      smoke_test_payload:
        description: "Optional custom payload for smoke test (JSON string). If not provided, uses default generic payload."
        required: false
        type: string
      runner:
        description: "Runner label (default: self-hosted)"
        required: false
        type: string
    secrets:
      aws_role_arn:
        description: "AWS IAM role ARN for OIDC"
        required: true
      aws_account_id:
        description: "AWS Account ID"
        required: true
      security_group_id_dev:
        description: "Optional Security Group ID for Lambda VPC configuration (DEV)"
        required: false
      security_group_id_prd:
        description: "Optional Security Group ID for Lambda VPC configuration (PRD)"
        required: false
      subnet_ids_dev:
        description: "Optional comma-delimited Subnet IDs for Lambda VPC configuration (DEV)"
        required: false
      subnet_ids_prd:
        description: "Optional comma-delimited Subnet IDs for Lambda VPC configuration (PRD)"
        required: false
      gitlab_api_token:
        description: "GitLab API token for private packages"
        required: false

jobs:
  test:
    if: inputs.run_tests
    runs-on: ${{ inputs.runner || 'self-hosted' }}
    env:
      HOME: ${{ github.workspace }}/.home
    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python (for self-hosted runners)
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use system Python or install if needed
          PYTHON_VERSION="${{ inputs.python_version }}"
          PYTHON_MAJOR_MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f1,2)

          # Find available Python
          PYTHON_CMD=""
          if command -v python${PYTHON_MAJOR_MINOR} &> /dev/null; then
            PYTHON_CMD="python${PYTHON_MAJOR_MINOR}"
            echo "Using system Python ${PYTHON_MAJOR_MINOR}"
            $PYTHON_CMD --version
          elif command -v python3 &> /dev/null; then
            PYTHON_CMD="python3"
            SYSTEM_VERSION=$($PYTHON_CMD --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            echo "Using system Python3 (version ${SYSTEM_VERSION})"
            $PYTHON_CMD --version
          else
            echo "Python not found, attempting to install..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3 python3-pip || true
            elif command -v /usr/bin/yum &> /dev/null; then
              sudo /usr/bin/yum install -y python3 python3-pip || true
            fi
            if command -v python3 &> /dev/null; then
              PYTHON_CMD="python3"
              $PYTHON_CMD --version
            else
              echo "Error: Could not find or install Python"
              exit 1
            fi
          fi

          # Install pip if not available
          if ! $PYTHON_CMD -m pip --version &>/dev/null; then
            echo "pip not found, installing..."
            # Try ensurepip first (built-in)
            if ! $PYTHON_CMD -m ensurepip --upgrade --default-pip 2>/dev/null; then
              echo "ensurepip failed, trying get-pip.py..."
              # Download get-pip.py
              /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
              if [ -f /tmp/get-pip.py ]; then
                # Try with --user first (doesn't require root)
                echo "Installing pip with get-pip.py (--user)..."
                $PYTHON_CMD /tmp/get-pip.py --user 2>&1 || true
                # If --user didn't work, try without --user (may require adding to PATH)
                if ! $PYTHON_CMD -m pip --version &>/dev/null; then
                  echo "Installing pip with get-pip.py (system-wide)..."
                  $PYTHON_CMD /tmp/get-pip.py 2>&1 || true
                fi
                # If pip is in user directory, add it to PATH
                if [ -f "$HOME/.local/bin/pip" ]; then
                  echo "$HOME/.local/bin" >> $GITHUB_PATH
                  export PATH="$HOME/.local/bin:$PATH"
                fi
                /bin/rm -f /tmp/get-pip.py
              fi
            fi
            # Try installing via package manager as last resort (non-fatal)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1; then
              echo "Trying package manager as last resort..."
              if command -v /usr/bin/apt-get &> /dev/null; then
                sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              elif command -v /usr/bin/yum &> /dev/null; then
                sudo /usr/bin/yum install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              fi
            fi
            # Verify pip is now available (check both locations)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1 && ! command -v pip &>/dev/null; then
              echo "Error: Failed to install pip. Python: $PYTHON_CMD"
              echo "Attempted: ensurepip, get-pip.py, package manager"
              exit 1
            fi
          fi

          # Add Python to PATH for subsequent steps
          echo "$PYTHON_CMD" >> $GITHUB_PATH || echo "$(which $PYTHON_CMD | xargs dirname)" >> $GITHUB_PATH

          # Create 'python' symlink if it doesn't exist
          if [ "$PYTHON_CMD" != "python" ] && ! command -v python &> /dev/null; then
            /bin/mkdir -p "$HOME/bin"
            /bin/ln -sf $(which $PYTHON_CMD) "$HOME/bin/python" 2>/dev/null || true
            echo "$HOME/bin" >> $GITHUB_PATH
          fi

          # Verify Python and pip are working
          echo "Python location: $(which $PYTHON_CMD)"
          echo "Python version:"
          $PYTHON_CMD --version
          echo "pip version:"
          # Check pip in multiple locations
          if $PYTHON_CMD -m pip --version &>/dev/null; then
            $PYTHON_CMD -m pip --version
          elif [ -f "$HOME/.local/bin/pip" ] && "$HOME/.local/bin/pip" --version &>/dev/null; then
            "$HOME/.local/bin/pip" --version
            echo "Note: pip is installed in ~/.local/bin"
          elif command -v pip &>/dev/null && pip --version &>/dev/null; then
            pip --version
          else
            echo "Warning: Could not verify pip installation"
          fi
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Install dependencies
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use python3 if python doesn't work, fallback to python
          if command -v python3 &> /dev/null && python3 -m pip --version &>/dev/null; then
            PYTHON_CMD="python3"
          elif command -v python &> /dev/null && python -m pip --version &>/dev/null; then
            PYTHON_CMD="python"
          else
            echo "Error: Neither python nor python3 with pip is available"
            exit 1
          fi

          # Create virtual environment to avoid externally-managed-environment error
          VENV_DIR="$HOME/venv"
          echo "Creating virtual environment at $VENV_DIR..."

          # Try to create venv with pip first
          if $PYTHON_CMD -m venv "$VENV_DIR" 2>/dev/null; then
            echo "Virtual environment created with pip"
          # If that fails, try without pip and install pip manually
          elif $PYTHON_CMD -m venv --without-pip "$VENV_DIR" 2>/dev/null; then
            echo "Virtual environment created without pip, installing pip..."
            # Install pip in the venv using get-pip.py
            /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
            if [ -f /tmp/get-pip.py ] && [ -f "$VENV_DIR/bin/python" ]; then
              "$VENV_DIR/bin/python" /tmp/get-pip.py 2>&1 || true
              /bin/rm -f /tmp/get-pip.py
            fi
          # If venv module doesn't work, try installing python3-venv
          else
            echo "venv module not available, trying to install python3-venv..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-venv || true
              # Try again after installing python3-venv
              if $PYTHON_CMD -m venv "$VENV_DIR" 2>/dev/null; then
                echo "Virtual environment created after installing python3-venv"
              elif $PYTHON_CMD -m venv --without-pip "$VENV_DIR" 2>/dev/null; then
                echo "Virtual environment created without pip, installing pip..."
                /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
                if [ -f /tmp/get-pip.py ] && [ -f "$VENV_DIR/bin/python" ]; then
                  "$VENV_DIR/bin/python" /tmp/get-pip.py 2>&1 || true
                  /bin/rm -f /tmp/get-pip.py
                fi
              fi
            fi
          fi

          # Activate virtual environment if it exists and has pip
          if [ -f "$VENV_DIR/bin/activate" ] && [ -f "$VENV_DIR/bin/pip" ]; then
            source "$VENV_DIR/bin/activate"
            echo "$VENV_DIR/bin" >> $GITHUB_PATH
            export PATH="$VENV_DIR/bin:$PATH"
            echo "Virtual environment activated with pip"
            PIP_CMD="pip"
          elif [ -f "$VENV_DIR/bin/activate" ]; then
            # Venv exists but no pip - try to use system pip with --user
            echo "Warning: Virtual environment created but pip not available, using --user flag"
            export PATH="$HOME/.local/bin:$PATH"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
            PIP_CMD="$PYTHON_CMD -m pip"
            PIP_FLAG="--user"
          else
            echo "Warning: Virtual environment not created, using --user flag as fallback"
            export PATH="$HOME/.local/bin:$PATH"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
            PIP_CMD="$PYTHON_CMD -m pip"
            PIP_FLAG="--user"
          fi

          # Upgrade pip in the environment
          if [ "$PIP_CMD" = "pip" ]; then
            pip install --upgrade pip || true
          else
            $PIP_CMD install $PIP_FLAG --upgrade pip || true
          fi

          if [ -f "${{ inputs.requirements_file }}" ]; then
            $PIP_CMD install $PIP_FLAG -r ${{ inputs.requirements_file }}
          fi

          # Install test dependencies
          $PIP_CMD install $PIP_FLAG pytest pytest-cov pytest-mock moto

      - name: Run tests
        run: |
          if [ -d "tests" ]; then
            echo "Running pytest..."
            pytest tests/ -v --cov=. --cov-report=term-missing
          else
            echo "No tests directory found, skipping tests"
          fi

  package:
    needs: [test]
    if: |
      always() &&
      (needs.test.result == 'success' || needs.test.result == 'skipped')
    runs-on: ${{ inputs.runner || 'self-hosted' }}
    env:
      HOME: ${{ github.workspace }}/.home
    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python (for self-hosted runners)
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use system Python or install if needed
          PYTHON_VERSION="${{ inputs.python_version }}"
          PYTHON_MAJOR_MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f1,2)

          # Find available Python
          PYTHON_CMD=""
          if command -v python${PYTHON_MAJOR_MINOR} &> /dev/null; then
            PYTHON_CMD="python${PYTHON_MAJOR_MINOR}"
            echo "Using system Python ${PYTHON_MAJOR_MINOR}"
            $PYTHON_CMD --version
          elif command -v python3 &> /dev/null; then
            PYTHON_CMD="python3"
            SYSTEM_VERSION=$($PYTHON_CMD --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            echo "Using system Python3 (version ${SYSTEM_VERSION})"
            $PYTHON_CMD --version
          else
            echo "Python not found, attempting to install..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3 python3-pip || true
            elif command -v /usr/bin/yum &> /dev/null; then
              sudo /usr/bin/yum install -y python3 python3-pip || true
            fi
            if command -v python3 &> /dev/null; then
              PYTHON_CMD="python3"
              $PYTHON_CMD --version
            else
              echo "Error: Could not find or install Python"
              exit 1
            fi
          fi

          # Install pip if not available
          if ! $PYTHON_CMD -m pip --version &>/dev/null; then
            echo "pip not found, installing..."
            # Try ensurepip first (built-in)
            if ! $PYTHON_CMD -m ensurepip --upgrade --default-pip 2>/dev/null; then
              echo "ensurepip failed, trying get-pip.py..."
              # Download get-pip.py
              /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
              if [ -f /tmp/get-pip.py ]; then
                # Try with --user first (doesn't require root)
                echo "Installing pip with get-pip.py (--user)..."
                $PYTHON_CMD /tmp/get-pip.py --user 2>&1 || true
                # If --user didn't work, try without --user (may require adding to PATH)
                if ! $PYTHON_CMD -m pip --version &>/dev/null; then
                  echo "Installing pip with get-pip.py (system-wide)..."
                  $PYTHON_CMD /tmp/get-pip.py 2>&1 || true
                fi
                # If pip is in user directory, add it to PATH
                if [ -f "$HOME/.local/bin/pip" ]; then
                  echo "$HOME/.local/bin" >> $GITHUB_PATH
                  export PATH="$HOME/.local/bin:$PATH"
                fi
                /bin/rm -f /tmp/get-pip.py
              fi
            fi
            # Try installing via package manager as last resort (non-fatal)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1; then
              echo "Trying package manager as last resort..."
              if command -v /usr/bin/apt-get &> /dev/null; then
                sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              elif command -v /usr/bin/yum &> /dev/null; then
                sudo /usr/bin/yum install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              fi
            fi
            # Verify pip is now available (check both locations)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1 && ! command -v pip &>/dev/null; then
              echo "Error: Failed to install pip. Python: $PYTHON_CMD"
              echo "Attempted: ensurepip, get-pip.py, package manager"
              exit 1
            fi
          fi

          # Add Python to PATH for subsequent steps
          echo "$PYTHON_CMD" >> $GITHUB_PATH || echo "$(which $PYTHON_CMD | xargs dirname)" >> $GITHUB_PATH

          # Create 'python' symlink if it doesn't exist
          if [ "$PYTHON_CMD" != "python" ] && ! command -v python &> /dev/null; then
            /bin/mkdir -p "$HOME/bin"
            /bin/ln -sf $(which $PYTHON_CMD) "$HOME/bin/python" 2>/dev/null || true
            echo "$HOME/bin" >> $GITHUB_PATH
          fi

          # Verify Python and pip are working
          echo "Python location: $(which $PYTHON_CMD)"
          echo "Python version:"
          $PYTHON_CMD --version
          echo "pip version:"
          # Check pip in multiple locations
          if $PYTHON_CMD -m pip --version &>/dev/null; then
            $PYTHON_CMD -m pip --version
          elif [ -f "$HOME/.local/bin/pip" ] && "$HOME/.local/bin/pip" --version &>/dev/null; then
            "$HOME/.local/bin/pip" --version
            echo "Note: pip is installed in ~/.local/bin"
          elif command -v pip &>/dev/null && pip --version &>/dev/null; then
            pip --version
          else
            echo "Warning: Could not verify pip installation"
          fi
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Package Lambda function
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use python3 if python doesn't work, fallback to python
          if command -v python3 &> /dev/null && python3 -m pip --version &>/dev/null; then
            PYTHON_CMD="python3"
          elif command -v python &> /dev/null && python -m pip --version &>/dev/null; then
            PYTHON_CMD="python"
          else
            echo "Error: Neither python nor python3 with pip is available"
            exit 1
          fi

          echo "=== Packaging Lambda Function ==="

          # Create package directory
          mkdir -p package

          # Install dependencies if requirements file exists
          if [ -f "${{ inputs.requirements_file }}" ]; then
            echo "Installing dependencies..."

            # Handle GitLab private packages if token provided
            if [ -n "${{ secrets.gitlab_api_token }}" ]; then
              echo "Configuring GitLab private package access..."
              $PYTHON_CMD -m pip install \
                --extra-index-url "https://__token__:${{ secrets.gitlab_api_token }}@gitlab.com/api/v4/projects/71621175/packages/pypi/simple" \
                -r ${{ inputs.requirements_file }} \
                -t package/
            else
              $PYTHON_CMD -m pip install -r ${{ inputs.requirements_file }} -t package/
            fi
          else
            echo "No requirements.txt found, skipping dependency installation"
          fi

          # Copy Lambda function code
          echo "Copying Lambda function code..."
          if [ -f "lambda_function.py" ]; then
            cp lambda_function.py package/
          elif [ -f "app.py" ]; then
            cp app.py package/
          else
            echo "Error: No lambda_function.py or app.py found"
            exit 1
          fi

          # Copy any additional Python files (excluding tests)
          find . -maxdepth 1 -name "*.py" ! -name "setup.py" ! -name "test_*.py" ! -name "*_test.py" -exec cp {} package/ \;

          # Create deployment package
          echo "Creating ZIP archive..."
          cd package
          zip -r ../function.zip . -x "*.pyc" -x "*__pycache__*" -x "*.git*"
          cd ..

          # Show package size
          ls -lh function.zip
          echo "✅ Lambda package created: $(du -h function.zip | cut -f1)"

      - name: Upload package artifact
        uses: actions/upload-artifact@v4
        with:
          name: lambda-package-${{ inputs.environment }}
          path: function.zip
          retention-days: 7

  deploy:
    needs: [package]
    if: |
      always() &&
      (needs.package.result == 'success')
    runs-on: ${{ inputs.runner || 'self-hosted' }}
    env:
      HOME: ${{ github.workspace }}/.home
    outputs:
      stack_name: ${{ steps.deploy.outputs.stack_name }}
      function_name: ${{ steps.deploy.outputs.function_name }}
    environment:
      name: ${{ inputs.environment }}
      url: https://console.aws.amazon.com/lambda/home?region=${{ inputs.aws_region }}#/functions/${{ inputs.function_name }}-${{ inputs.environment }}
    permissions:
      id-token: write # Required for OIDC
      contents: read

    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Debug - Check job context
        run: |
          echo "=== Deploy Job Debug Info ==="
          echo "Environment: ${{ inputs.environment }}"
          echo "Function Name: ${{ inputs.function_name }}"
          echo "Stack Name: ${{ inputs.stack_name }}"
          echo "AWS Region: ${{ inputs.aws_region }}"
          echo "Package Job Result: ${{ needs.package.result }}"
          echo "GitHub Event: ${{ github.event_name }}"
          echo "GitHub Ref: ${{ github.ref }}"
          echo "Run ID: ${{ github.run_id }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download package artifact
        uses: actions/download-artifact@v4
        with:
          name: lambda-package-${{ inputs.environment }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.aws_role_arn }}
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-lambda-deploy

      - name: Install AWS CLI and jq
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Check if AWS CLI is already installed
          if command -v aws &> /dev/null; then
            echo "AWS CLI is already installed: $(aws --version)"
          else
            echo "=== Installing AWS CLI ==="
            AWS_CLI_INSTALLED=false

            # Try installing via pip first (works well on self-hosted runners)
            if command -v python3 &> /dev/null && python3 -m pip --version &>/dev/null; then
              echo "Attempting to install AWS CLI via pip..."
              if python3 -m pip install --user awscli 2>&1 || python3 -m pip install awscli 2>&1; then
                # Add user bin to PATH if installed with --user
                if [ -f "$HOME/.local/bin/aws" ]; then
                  echo "$HOME/.local/bin" >> $GITHUB_PATH
                  export PATH="$HOME/.local/bin:$PATH"
                fi
                # Verify it's actually available
                if command -v aws &> /dev/null; then
                  AWS_CLI_INSTALLED=true
                  echo "✅ AWS CLI installed via pip: $(aws --version)"
                fi
              fi
            fi

            # If pip installation failed, try AWS CLI v2 installer
            if [ "$AWS_CLI_INSTALLED" = false ]; then
              echo "Pip installation failed or not available, trying AWS CLI v2 installer..."
              ARCH=$(uname -m)
              if [ "$ARCH" = "x86_64" ]; then
                ARCH="x86_64"
              elif [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
                ARCH="aarch64"
              else
                ARCH="x86_64"  # Default fallback
              fi

              INSTALL_DIR="$HOME/aws-cli"
              mkdir -p "$INSTALL_DIR"
              
              # Download and install AWS CLI v2
              if curl -sSL "https://awscli.amazonaws.com/awscli-exe-linux-${ARCH}.zip" -o /tmp/awscliv2.zip; then
                if command -v unzip &> /dev/null || (command -v /usr/bin/apt-get &> /dev/null && sudo /usr/bin/apt-get install -y unzip); then
                  unzip -q /tmp/awscliv2.zip -d /tmp/
                  if [ -f /tmp/aws/install ]; then
                    /tmp/aws/install -i "$INSTALL_DIR" -b "$HOME/.local/bin" 2>&1
                    echo "$HOME/.local/bin" >> $GITHUB_PATH
                    export PATH="$HOME/.local/bin:$PATH"
                    rm -rf /tmp/aws /tmp/awscliv2.zip
                    # Verify installation
                    if command -v aws &> /dev/null; then
                      AWS_CLI_INSTALLED=true
                      echo "✅ AWS CLI v2 installed: $(aws --version)"
                    fi
                  fi
                fi
              fi
            fi

            # Last resort: try package manager (but don't fail if it's not available)
            if [ "$AWS_CLI_INSTALLED" = false ]; then
              echo "Trying package manager as last resort..."
              if command -v /usr/bin/apt-get &> /dev/null; then
                sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y awscli 2>&1 || echo "Package manager installation failed (package may not be available)"
              elif command -v /usr/bin/yum &> /dev/null; then
                sudo /usr/bin/yum install -y awscli 2>&1 || echo "Package manager installation failed (package may not be available)"
              fi
              # Check if it worked
              if command -v aws &> /dev/null; then
                AWS_CLI_INSTALLED=true
                echo "✅ AWS CLI installed via package manager: $(aws --version)"
              fi
            fi

            # Final verification
            if [ "$AWS_CLI_INSTALLED" = false ]; then
              echo "❌ Failed to install AWS CLI using all available methods"
              echo "   Attempted: pip, AWS CLI v2 installer, package manager"
              exit 1
            fi
          fi

          # Check if jq is already installed
          if command -v jq &> /dev/null; then
            echo "jq is already installed: $(jq --version)"
          else
            echo "=== Installing jq ==="
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y jq || true
            elif command -v /usr/bin/yum &> /dev/null; then
              sudo /usr/bin/yum install -y jq || true
            fi
            # Verify installation
            if command -v jq &> /dev/null; then
              echo "✅ jq installed: $(jq --version)"
            else
              echo "⚠️  Warning: jq installation failed, but continuing..."
            fi
          fi
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Verify AWS Identity and Account
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"
          # Add user bin to PATH if AWS CLI was installed there
          if [ -f "$HOME/.local/bin/aws" ]; then
            export PATH="$HOME/.local/bin:$PATH"
          fi

          echo "=== AWS Identity Verification ==="

          # Get full caller identity
          IDENTITY=$(aws sts get-caller-identity)
          echo "$IDENTITY"

          # Extract account ID (use Python if jq is not available)
          if command -v jq &> /dev/null; then
            ACTUAL_ACCOUNT=$(echo "$IDENTITY" | jq -r .Account)
            ACTUAL_ARN=$(echo "$IDENTITY" | jq -r .Arn)
          else
            # Fallback to Python for JSON parsing
            ACTUAL_ACCOUNT=$(echo "$IDENTITY" | python3 -c "import sys, json; print(json.load(sys.stdin)['Account'])" 2>/dev/null || echo "")
            ACTUAL_ARN=$(echo "$IDENTITY" | python3 -c "import sys, json; print(json.load(sys.stdin)['Arn'])" 2>/dev/null || echo "")
          fi

          echo ""
          echo "=== Identity Details ==="
          echo "Actual Account ID: ${ACTUAL_ACCOUNT}"
          echo "Expected Account ID: ${{ secrets.aws_account_id }}"
          echo "Region: ${{ inputs.aws_region }}"

          # Verify account matches
          if [ "${ACTUAL_ACCOUNT}" != "${{ secrets.aws_account_id }}" ]; then
            echo ""
            echo "❌ ERROR: Account mismatch detected!"
            echo "   Expected: ${{ secrets.aws_account_id }}"
            echo "   Actual: ${ACTUAL_ACCOUNT}"
            echo ""
            echo "Fix: Update AWS_ACCOUNT_ID secret to match the role's account"
            exit 1
          fi

          echo "✅ Authenticated to correct account: ${{ inputs.environment }}"

      - name: Test S3 Permissions
        if: inputs.verify_s3_permissions
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"
          # Add user bin to PATH if AWS CLI was installed there
          if [ -f "$HOME/.local/bin/aws" ]; then
            export PATH="$HOME/.local/bin:$PATH"
          fi

          echo "=== Testing S3 Permissions ==="

          ARTIFACTS_BUCKET="cloudbot-codepipeline-artifacts-${{ inputs.aws_region }}-${{ secrets.aws_account_id }}"
          ACTUAL_ACCOUNT=$(aws sts get-caller-identity --query Account --output text)

          echo "Target Bucket: ${ARTIFACTS_BUCKET}"
          echo "Authenticated Account: ${ACTUAL_ACCOUNT}"

          # Verify bucket exists
          echo ""
          echo "1. Verifying bucket exists..."
          if aws s3api head-bucket --bucket "${ARTIFACTS_BUCKET}" 2>&1; then
            echo "✅ Bucket exists and is accessible"
          else
            echo "❌ Bucket doesn't exist or not accessible"
            exit 1
          fi

          echo ""
          echo "2. Testing ListBucket..."
          if aws s3 ls "s3://${ARTIFACTS_BUCKET}/lambda-packages/" 2>&1; then
            echo "✅ ListBucket succeeded"
          else
            echo "⚠️  ListBucket failed (may need to create prefix)"
          fi

          echo ""
          echo "3. Testing PutObject with KMS..."
          echo "test-content" > /tmp/test-permissions.txt
          if aws s3 cp /tmp/test-permissions.txt "s3://${ARTIFACTS_BUCKET}/test-github-actions-${{ github.run_id }}.txt" \
            --sse aws:kms \
            --sse-kms-key-id ${{ inputs.kms_key_alias }} 2>&1; then
            echo "✅ PutObject succeeded"
            
            # Clean up test file
            echo ""
            echo "4. Testing DeleteObject..."
            if aws s3 rm "s3://${ARTIFACTS_BUCKET}/test-github-actions-${{ github.run_id }}.txt" 2>&1; then
              echo "✅ DeleteObject succeeded"
            else
              echo "⚠️  DeleteObject failed (not critical)"
            fi
          else
            echo "❌ PutObject failed"
            exit 1
          fi

          echo ""
          echo "✅ All S3 permission tests passed!"

      - name: Setup Python (for self-hosted runners)
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use system Python or install if needed
          PYTHON_VERSION="${{ inputs.python_version }}"
          PYTHON_MAJOR_MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f1,2)

          # Find available Python
          PYTHON_CMD=""
          if command -v python${PYTHON_MAJOR_MINOR} &> /dev/null; then
            PYTHON_CMD="python${PYTHON_MAJOR_MINOR}"
            echo "Using system Python ${PYTHON_MAJOR_MINOR}"
            $PYTHON_CMD --version
          elif command -v python3 &> /dev/null; then
            PYTHON_CMD="python3"
            SYSTEM_VERSION=$($PYTHON_CMD --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            echo "Using system Python3 (version ${SYSTEM_VERSION})"
            $PYTHON_CMD --version
          else
            echo "Python not found, attempting to install..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3 python3-pip || true
            elif command -v /usr/bin/yum &> /dev/null; then
              sudo /usr/bin/yum install -y python3 python3-pip || true
            fi
            if command -v python3 &> /dev/null; then
              PYTHON_CMD="python3"
              $PYTHON_CMD --version
            else
              echo "Error: Could not find or install Python"
              exit 1
            fi
          fi

          # Install pip if not available
          if ! $PYTHON_CMD -m pip --version &>/dev/null; then
            echo "pip not found, installing..."
            # Try ensurepip first (built-in)
            if ! $PYTHON_CMD -m ensurepip --upgrade --default-pip 2>/dev/null; then
              echo "ensurepip failed, trying get-pip.py..."
              # Download get-pip.py
              /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
              if [ -f /tmp/get-pip.py ]; then
                # Try with --user first (doesn't require root)
                echo "Installing pip with get-pip.py (--user)..."
                $PYTHON_CMD /tmp/get-pip.py --user 2>&1 || true
                # If --user didn't work, try without --user (may require adding to PATH)
                if ! $PYTHON_CMD -m pip --version &>/dev/null; then
                  echo "Installing pip with get-pip.py (system-wide)..."
                  $PYTHON_CMD /tmp/get-pip.py 2>&1 || true
                fi
                # If pip is in user directory, add it to PATH
                if [ -f "$HOME/.local/bin/pip" ]; then
                  echo "$HOME/.local/bin" >> $GITHUB_PATH
                  export PATH="$HOME/.local/bin:$PATH"
                fi
                /bin/rm -f /tmp/get-pip.py
              fi
            fi
            # Try installing via package manager as last resort (non-fatal)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1; then
              echo "Trying package manager as last resort..."
              if command -v /usr/bin/apt-get &> /dev/null; then
                sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              elif command -v /usr/bin/yum &> /dev/null; then
                sudo /usr/bin/yum install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              fi
            fi
            # Verify pip is now available (check both locations)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1 && ! command -v pip &>/dev/null; then
              echo "Error: Failed to install pip. Python: $PYTHON_CMD"
              echo "Attempted: ensurepip, get-pip.py, package manager"
              exit 1
            fi
          fi

          # Add Python to PATH for subsequent steps
          echo "$PYTHON_CMD" >> $GITHUB_PATH || echo "$(which $PYTHON_CMD | xargs dirname)" >> $GITHUB_PATH

          # Create 'python' symlink if it doesn't exist
          if [ "$PYTHON_CMD" != "python" ] && ! command -v python &> /dev/null; then
            /bin/mkdir -p "$HOME/bin"
            /bin/ln -sf $(which $PYTHON_CMD) "$HOME/bin/python" 2>/dev/null || true
            echo "$HOME/bin" >> $GITHUB_PATH
          fi

          # Verify Python and pip are working
          echo "Python location: $(which $PYTHON_CMD)"
          echo "Python version:"
          $PYTHON_CMD --version
          echo "pip version:"
          # Check pip in multiple locations
          if $PYTHON_CMD -m pip --version &>/dev/null; then
            $PYTHON_CMD -m pip --version
          elif [ -f "$HOME/.local/bin/pip" ] && "$HOME/.local/bin/pip" --version &>/dev/null; then
            "$HOME/.local/bin/pip" --version
            echo "Note: pip is installed in ~/.local/bin"
          elif command -v pip &>/dev/null && pip --version &>/dev/null; then
            pip --version
          else
            echo "Warning: Could not verify pip installation"
          fi
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Install SAM CLI
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use python3 if python doesn't work, fallback to python
          if command -v python3 &> /dev/null && python3 -m pip --version &>/dev/null; then
            PYTHON_CMD="python3"
          elif command -v python &> /dev/null && python -m pip --version &>/dev/null; then
            PYTHON_CMD="python"
          else
            echo "Error: Neither python nor python3 with pip is available"
            exit 1
          fi

          echo "=== Installing SAM CLI ==="

          # Try installing with --user flag first (avoids externally-managed-environment error)
          if $PYTHON_CMD -m pip install --user aws-sam-cli 2>&1; then
            echo "✅ SAM CLI installed with --user flag"
            # Add user bin to PATH
            if [ -f "$HOME/.local/bin/sam" ]; then
              echo "$HOME/.local/bin" >> $GITHUB_PATH
              export PATH="$HOME/.local/bin:$PATH"
            fi
          else
            echo "⚠️  --user installation failed, trying virtual environment approach..."
            # Create a virtual environment for SAM CLI
            VENV_DIR="$HOME/sam-venv"
            if $PYTHON_CMD -m venv "$VENV_DIR" 2>/dev/null || $PYTHON_CMD -m venv --without-pip "$VENV_DIR" 2>/dev/null; then
              # Activate venv and install SAM CLI
              source "$VENV_DIR/bin/activate" 2>/dev/null || true
              export PATH="$VENV_DIR/bin:$PATH"
              echo "$VENV_DIR/bin" >> $GITHUB_PATH
              
              # Install pip in venv if needed
              if [ ! -f "$VENV_DIR/bin/pip" ]; then
                curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
                if [ -f /tmp/get-pip.py ] && [ -f "$VENV_DIR/bin/python" ]; then
                  "$VENV_DIR/bin/python" /tmp/get-pip.py 2>&1 || true
                  rm -f /tmp/get-pip.py
                fi
              fi
              
              # Install SAM CLI in venv
              if [ -f "$VENV_DIR/bin/pip" ]; then
                "$VENV_DIR/bin/pip" install aws-sam-cli 2>&1
                echo "✅ SAM CLI installed in virtual environment"
              else
                echo "❌ Failed to install pip in virtual environment"
                exit 1
              fi
            else
              echo "❌ Failed to create virtual environment and --user installation failed"
              exit 1
            fi
          fi

          # Verify SAM CLI is available
          if command -v sam &> /dev/null; then
            sam --version
          else
            echo "❌ SAM CLI not found in PATH"
            exit 1
          fi
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Upload to S3
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"
          # Add user bin to PATH if AWS CLI was installed there
          if [ -f "$HOME/.local/bin/aws" ]; then
            export PATH="$HOME/.local/bin:$PATH"
          fi

          echo "=== Uploading to S3 ==="

          # S3 bucket for artifacts (matches GitLab CI/CD approach)
          ARTIFACTS_BUCKET="cloudbot-codepipeline-artifacts-${{ inputs.aws_region }}-${{ secrets.aws_account_id }}"
          S3_KEY="lambda-packages/${{ inputs.function_name }}/function-${{ github.sha }}.zip"

          echo "Bucket: ${ARTIFACTS_BUCKET}"
          echo "Key: ${S3_KEY}"

          # Upload to S3 with KMS encryption (required by bucket policy)
          aws s3 cp function.zip "s3://${ARTIFACTS_BUCKET}/${S3_KEY}" \
            --sse aws:kms \
            --sse-kms-key-id ${{ inputs.kms_key_alias }}

          echo "s3_bucket=${ARTIFACTS_BUCKET}" >> $GITHUB_ENV
          echo "s3_key=${S3_KEY}" >> $GITHUB_ENV

          echo "✅ Package uploaded to S3 with KMS encryption"

      - name: Deploy with SAM
        run: |
          echo "=== Deploying with SAM ==="

          # Determine stack name
          if [ -n "${{ inputs.stack_name }}" ]; then
            STACK_NAME="${{ inputs.stack_name }}"
          else
            STACK_NAME="${{ inputs.function_name }}-stack"
          fi

          echo "Stack Name: ${STACK_NAME}"
          echo "Template: ${{ inputs.sam_template }}"

          # Verify template exists
          if [ ! -f "${{ inputs.sam_template }}" ]; then
            echo "❌ Error: SAM template not found: ${{ inputs.sam_template }}"
            exit 1
          fi

          # Build parameter overrides
          PARAM_OVERRIDES="ARTIFACTSBUCKET=${{ env.s3_bucket }} S3Key=${{ env.s3_key }} ACCOUNTID=${{ secrets.aws_account_id }} NAME=${{ inputs.function_name }}"

          # Select VPC configuration based on environment
          ENV="${{ inputs.environment }}"
          if [ "${ENV}" == "dev" ]; then
            SECURITY_GROUP_ID="${{ secrets.security_group_id_dev }}"
            SUBNET_IDS="${{ secrets.subnet_ids_dev }}"
          elif [ "${ENV}" == "prd" ]; then
            SECURITY_GROUP_ID="${{ secrets.security_group_id_prd }}"
            SUBNET_IDS="${{ secrets.subnet_ids_prd }}"
          else
            SECURITY_GROUP_ID=""
            SUBNET_IDS=""
          fi

          # Add VPC parameters if provided
          if [ -n "${SECURITY_GROUP_ID}" ] && [ -n "${SUBNET_IDS}" ]; then
            PARAM_OVERRIDES="${PARAM_OVERRIDES} SecurityGroupId=${SECURITY_GROUP_ID} SubnetIds=${SUBNET_IDS}"
            echo "VPC Configuration: SecurityGroup=${SECURITY_GROUP_ID}, Subnets=${SUBNET_IDS}"
          else
            echo "No VPC configuration provided - deploying without VPC"
          fi

          # Deploy using SAM (matches GitLab CI/CD approach)
          sam deploy \
            --template-file ${{ inputs.sam_template }} \
            --stack-name ${STACK_NAME} \
            --parameter-overrides ${PARAM_OVERRIDES} \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --region ${{ inputs.aws_region }}

          echo "stack_name=${STACK_NAME}" >> $GITHUB_ENV
          echo "✅ SAM deployment completed"

      - name: Get function info
        id: deploy
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"
          # Add user bin to PATH if AWS CLI was installed there
          if [ -f "$HOME/.local/bin/aws" ]; then
            export PATH="$HOME/.local/bin:$PATH"
          fi

          echo "=== Lambda Function Info ==="

          # Get function name from stack outputs
          FUNCTION_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.stack_name }} \
            --region ${{ inputs.aws_region }} \
            --query 'Stacks[0].Outputs[?OutputKey==`LambdaFunctionName`].OutputValue' \
            --output text)

          if [ -z "${FUNCTION_NAME}" ] || [ "${FUNCTION_NAME}" == "None" ]; then
            echo "⚠️  Could not get function name from stack outputs, trying direct lookup..."
            FUNCTION_NAME="${{ inputs.function_name }}"
          fi

          echo "Function Name: ${FUNCTION_NAME}"

          # Get function configuration
          aws lambda get-function-configuration \
            --function-name ${FUNCTION_NAME} \
            --region ${{ inputs.aws_region }} \
            --query '{Runtime:Runtime,LastModified:LastModified,CodeSize:CodeSize,State:State,Version:Version}' \
            --output table

          # Set outputs for smoke-test job
          echo "stack_name=${{ env.stack_name }}" >> $GITHUB_OUTPUT
          echo "function_name=${FUNCTION_NAME}" >> $GITHUB_OUTPUT

          echo "✅ Deployment verified"

  smoke-test:
    needs: [deploy]
    if: |
      always() && 
      (needs.deploy.result == 'success')
    runs-on: ${{ inputs.runner || 'self-hosted' }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.aws_role_arn }}
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-smoke-test-${{ github.run_id }}

      - name: Verify AWS CLI installation
        run: |
          echo "=== Verifying AWS CLI ==="
          AWS_CLI_PATH=""

          if command -v aws &> /dev/null; then
            echo "✅ AWS CLI found in PATH"
            AWS_CLI_PATH=$(which aws)
          else
            echo "⚠️  AWS CLI not found in PATH, attempting to locate..."
            # Check common installation locations
            if [ -f /usr/local/bin/aws ]; then
              echo "Found AWS CLI at /usr/local/bin/aws"
              AWS_CLI_PATH="/usr/local/bin/aws"
              echo "/usr/local/bin" >> $GITHUB_PATH
            elif [ -f /usr/bin/aws ]; then
              echo "Found AWS CLI at /usr/bin/aws"
              AWS_CLI_PATH="/usr/bin/aws"
              echo "/usr/bin" >> $GITHUB_PATH
            elif [ -f "$HOME/.local/bin/aws" ]; then
              echo "Found AWS CLI at $HOME/.local/bin/aws"
              AWS_CLI_PATH="$HOME/.local/bin/aws"
              echo "$HOME/.local/bin" >> $GITHUB_PATH
            else
              echo "❌ AWS CLI not found - installing via pip..."
              pip install --user awscli
              AWS_CLI_PATH="$HOME/.local/bin/aws"
              echo "$HOME/.local/bin" >> $GITHUB_PATH
            fi
          fi

          # Verify AWS CLI works
          aws --version || {
            echo "❌ AWS CLI verification failed"
            echo "AWS CLI path: ${AWS_CLI_PATH}"
            exit 1
          }

          echo "✅ AWS CLI verified at: $(which aws)"

      - name: Run smoke test
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"
          # Add user bin to PATH if AWS CLI was installed there
          if [ -f "$HOME/.local/bin/aws" ]; then
            export PATH="$HOME/.local/bin:$PATH"
          fi

          echo "=== Running Smoke Test ==="

          # Use function name from deploy job output if available
          if [ -n "${{ needs.deploy.outputs.function_name }}" ]; then
            FUNCTION_NAME="${{ needs.deploy.outputs.function_name }}"
          elif [ -n "${{ needs.deploy.outputs.stack_name }}" ]; then
            # Fallback: get from stack
            FUNCTION_NAME=$(aws cloudformation describe-stacks \
              --stack-name ${{ needs.deploy.outputs.stack_name }} \
              --region ${{ inputs.aws_region }} \
              --query 'Stacks[0].Outputs[?OutputKey==`LambdaFunctionName`].OutputValue' \
              --output text)
          fi

          if [ -z "${FUNCTION_NAME}" ] || [ "${FUNCTION_NAME}" == "None" ]; then
            echo "⚠️  Could not get function name from stack, using input name"
            FUNCTION_NAME="${{ inputs.function_name }}"
          fi

          echo "Testing function: ${FUNCTION_NAME}"

          # Use custom payload if provided, otherwise use default
          if [ -n "${{ inputs.smoke_test_payload }}" ]; then
            PAYLOAD="${{ inputs.smoke_test_payload }}"
            echo "Using custom smoke test payload"
          else
            PAYLOAD='{"message": "GitHub Actions deployment test"}'
            echo "Using default smoke test payload"
          fi

          echo ""
          echo "Test 1: Simple invocation"
          echo "Payload:"
          echo "${PAYLOAD}" | jq . 2>/dev/null || echo "${PAYLOAD}"

          aws lambda invoke \
            --function-name ${FUNCTION_NAME} \
            --cli-binary-format raw-in-base64-out \
            --payload "${PAYLOAD}" \
            --region ${{ inputs.aws_region }} \
            response.json

          echo ""
          echo "Response:"
          cat response.json | jq . 2>/dev/null || cat response.json

          # Check response status code
          STATUS_CODE=$(cat response.json | jq -r '.StatusCode // 200')
          FUNCTION_ERROR=$(cat response.json | jq -r '.FunctionError // "None"')

          echo ""
          echo "Status Code: ${STATUS_CODE}"
          echo "Function Error: ${FUNCTION_ERROR}"

          # Lenient smoke test: Accept handled errors (StatusCode 200 with errorMessage)
          # but fail on unhandled exceptions (FunctionError: Unhandled)
          if [ "${FUNCTION_ERROR}" == "Unhandled" ]; then
            echo ""
            echo "❌ Smoke test failed - function raised unhandled exception"
            cat response.json
            exit 1
          elif [ "${STATUS_CODE}" != "200" ]; then
            echo ""
            echo "❌ Smoke test failed - unexpected status code: ${STATUS_CODE}"
            cat response.json
            exit 1
          elif grep -q "errorMessage" response.json; then
            # Function returned a handled error (StatusCode 200 but with errorMessage)
            # This is acceptable for smoke tests - function executed successfully
            echo ""
            echo "⚠️  Function returned handled error (expected for invalid test input)"
            echo "✅ Function executed successfully - deployment validated"
          else
            # Function returned success
            echo ""
            echo "✅ Test 1 passed - function returned success"
          fi

          echo ""
          echo "=== Smoke Test Summary ==="
          echo "Function: ${FUNCTION_NAME}"
          echo "Environment: ${{ inputs.environment }}"
          echo "✅ Lambda invoked successfully - deployment validated!"
