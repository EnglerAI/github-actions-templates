name: Lambda Layer Deploy

on:
  workflow_call:
    inputs:
      layer_name:
        description: "Name of Lambda layer (required)"
        required: true
        type: string
      stack_name:
        description: "CloudFormation stack name (defaults to layer_name-stack)"
        required: false
        type: string
      environment:
        description: "Target environment (dev/qat/stg/prd)"
        required: true
        type: string
      aws_region:
        description: "AWS region"
        required: true
        type: string
        default: "us-east-2"
      python_version:
        description: "Python version"
        required: false
        type: string
        default: "3.12"
      sam_template:
        description: "Path to SAM template file"
        required: false
        type: string
        default: "template.yml"
      requirements_file:
        description: "Path to requirements.txt (relative to repo root)"
        required: false
        type: string
        default: "requirements.txt"
      layer_code_directory:
        description: "Directory containing layer code (defaults to 'python')"
        required: false
        type: string
        default: "python"
      kms_key_alias:
        description: "KMS key alias for S3 encryption"
        required: false
        type: string
        default: "alias/CloudBotPipelineKey"
      runner:
        description: "Runner label (default: self-hosted)"
        required: false
        type: string
    secrets:
      aws_role_arn:
        description: "AWS IAM role ARN for OIDC"
        required: true
      aws_account_id:
        description: "AWS Account ID"
        required: true
      gitlab_api_token:
        description: "GitLab API token for private packages"
        required: false

jobs:
  package:
    runs-on: ${{ inputs.runner || 'self-hosted' }}
    env:
      HOME: ${{ github.workspace }}/.home
    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python (for self-hosted runners)
        run: |
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use system Python or install if needed
          PYTHON_VERSION="${{ inputs.python_version }}"
          PYTHON_MAJOR_MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f1,2)

          # Find available Python
          PYTHON_CMD=""
          if command -v python${PYTHON_MAJOR_MINOR} &> /dev/null; then
            PYTHON_CMD="python${PYTHON_MAJOR_MINOR}"
            echo "Using system Python ${PYTHON_MAJOR_MINOR}"
            $PYTHON_CMD --version
          elif command -v python3 &> /dev/null; then
            PYTHON_CMD="python3"
            SYSTEM_VERSION=$($PYTHON_CMD --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            echo "Using system Python3 (version ${SYSTEM_VERSION})"
            $PYTHON_CMD --version
          else
            echo "Python not found, attempting to install..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3 python3-pip || true
            elif command -v /usr/bin/yum &> /dev/null; then
              sudo /usr/bin/yum install -y python3 python3-pip || true
            fi
            if command -v python3 &> /dev/null; then
              PYTHON_CMD="python3"
              $PYTHON_CMD --version
            else
              echo "Error: Could not find or install Python"
              exit 1
            fi
          fi

          # Install pip if not available
          if ! $PYTHON_CMD -m pip --version &>/dev/null; then
            echo "pip not found, installing..."
            # Try ensurepip first (built-in)
            if ! $PYTHON_CMD -m ensurepip --upgrade --default-pip 2>/dev/null; then
              echo "ensurepip failed, trying get-pip.py..."
              # Download get-pip.py
              /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
              if [ -f /tmp/get-pip.py ]; then
                # Try with --user first (doesn't require root)
                echo "Installing pip with get-pip.py (--user)..."
                $PYTHON_CMD /tmp/get-pip.py --user 2>&1 || true
                # If --user didn't work, try without --user (may require adding to PATH)
                if ! $PYTHON_CMD -m pip --version &>/dev/null; then
                  echo "Installing pip with get-pip.py (system-wide)..."
                  $PYTHON_CMD /tmp/get-pip.py 2>&1 || true
                fi
                # If pip is in user directory, add it to PATH
                if [ -f "$HOME/.local/bin/pip" ]; then
                  echo "$HOME/.local/bin" >> $GITHUB_PATH
                  export PATH="$HOME/.local/bin:$PATH"
                fi
                /bin/rm -f /tmp/get-pip.py
              fi
            fi
            # Try installing via package manager as last resort (non-fatal)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1; then
              echo "Trying package manager as last resort..."
              if command -v /usr/bin/apt-get &> /dev/null; then
                sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              elif command -v /usr/bin/yum &> /dev/null; then
                sudo /usr/bin/yum install -y python3-pip 2>&1 || echo "Package manager installation failed, continuing..."
              fi
            fi
            # Verify pip is now available (check both locations)
            if ! $PYTHON_CMD -m pip --version &>/dev/null && ! "$HOME/.local/bin/pip" --version &>/dev/null 2>&1 && ! command -v pip &>/dev/null; then
              echo "Error: Failed to install pip. Python: $PYTHON_CMD"
              echo "Attempted: ensurepip, get-pip.py, package manager"
              exit 1
            fi
          fi

          # Add Python to PATH for subsequent steps
          echo "$PYTHON_CMD" >> $GITHUB_PATH || echo "$(which $PYTHON_CMD | xargs dirname)" >> $GITHUB_PATH

          # Create 'python' symlink if it doesn't exist
          if [ "$PYTHON_CMD" != "python" ] && ! command -v python &> /dev/null; then
            /bin/mkdir -p "$HOME/bin"
            /bin/ln -sf $(which $PYTHON_CMD) "$HOME/bin/python" 2>/dev/null || true
            echo "$HOME/bin" >> $GITHUB_PATH
          fi

          # Verify Python and pip are working
          echo "Python location: $(which $PYTHON_CMD)"
          echo "Python version:"
          $PYTHON_CMD --version
          echo "pip version:"
          # Check pip in multiple locations
          if $PYTHON_CMD -m pip --version &>/dev/null; then
            $PYTHON_CMD -m pip --version
          elif [ -f "$HOME/.local/bin/pip" ] && "$HOME/.local/bin/pip" --version &>/dev/null; then
            "$HOME/.local/bin/pip" --version
            echo "Note: pip is installed in ~/.local/bin"
          elif command -v pip &>/dev/null && pip --version &>/dev/null; then
            pip --version
          else
            echo "Warning: Could not verify pip installation"
          fi
        env:
          HOME: ${{ github.workspace }}/.home

      - name: Package Lambda Layer
        run: |
          echo "=== Packaging Lambda Layer ==="

          # Lambda Layers require the code in a specific directory structure
          # For Python layers, code must be in the specified directory (default: 'python')
          LAYER_DIR="${{ inputs.layer_code_directory }}"

          if [ ! -d "${LAYER_DIR}" ]; then
            echo "❌ Error: '${LAYER_DIR}' directory not found"
            echo "Lambda Layers require code in a '${LAYER_DIR}' directory"
            exit 1
          fi

          # Create layer package directory
          mkdir -p layer-package

          # Copy layer code directory to layer-package
          echo "Copying ${LAYER_DIR} directory to layer package..."
          cp -r "${LAYER_DIR}" layer-package/

          # Install any dependencies if requirements file exists
          REQ_FILE="${{ inputs.requirements_file }}"
          if [ -f "${LAYER_DIR}/requirements.txt" ]; then
            echo "Installing dependencies from ${LAYER_DIR}/requirements.txt..."
            # Handle GitLab private packages if token provided
            if [ -n "${{ secrets.gitlab_api_token }}" ]; then
              pip install \
                --extra-index-url "https://__token__:${{ secrets.gitlab_api_token }}@gitlab.com/api/v4/projects/71621175/packages/pypi/simple" \
                -r "${LAYER_DIR}/requirements.txt" \
                -t "layer-package/${LAYER_DIR}/"
            else
              pip install -r "${LAYER_DIR}/requirements.txt" -t "layer-package/${LAYER_DIR}/"
            fi
          elif [ -f "${REQ_FILE}" ]; then
            echo "Installing dependencies from ${REQ_FILE}..."
            # Handle GitLab private packages if token provided
            if [ -n "${{ secrets.gitlab_api_token }}" ]; then
              pip install \
                --extra-index-url "https://__token__:${{ secrets.gitlab_api_token }}@gitlab.com/api/v4/projects/71621175/packages/pypi/simple" \
                -r "${REQ_FILE}" \
                -t "layer-package/${LAYER_DIR}/"
            else
              pip install -r "${REQ_FILE}" -t "layer-package/${LAYER_DIR}/"
            fi
          else
            echo "No requirements.txt found, skipping dependency installation"
          fi

          # Create ZIP archive for the layer
          echo "Creating layer ZIP archive..."
          cd layer-package
          zip -r ../layer.zip . -x "*.pyc" -x "*__pycache__*" -x "*.git*" -x "*.pytest_cache*"
          cd ..

          # Show package size
          ls -lh layer.zip
          echo "✅ Lambda layer package created: $(du -h layer.zip | cut -f1)"

      - name: Upload layer package artifact
        uses: actions/upload-artifact@v4
        with:
          name: lambda-layer-package-${{ inputs.environment }}
          path: layer.zip
          retention-days: 7

  deploy:
    needs: [package]
    if: |
      always() && 
      (needs.package.result == 'success')
    runs-on: ${{ inputs.runner || 'self-hosted' }}
    outputs:
      stack_name: ${{ steps.deploy.outputs.stack_name }}
      layer_arn: ${{ steps.deploy.outputs.layer_arn }}
    environment:
      name: ${{ inputs.environment }}
      url: https://console.aws.amazon.com/lambda/home?region=${{ inputs.aws_region }}#/layers
    permissions:
      id-token: write # Required for OIDC
      contents: read
    env:
      HOME: ${{ github.workspace }}/.home

    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download layer package artifact
        uses: actions/download-artifact@v4
        with:
          name: lambda-layer-package-${{ inputs.environment }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.aws_role_arn }}
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-layer-deploy

      - name: Upload layer package to S3
        run: |
          echo "=== Uploading Layer Package to S3 ==="

          # S3 bucket for artifacts (matches GitLab CI/CD approach)
          ARTIFACTS_BUCKET="cloudbot-codepipeline-artifacts-${{ inputs.aws_region }}-${{ secrets.aws_account_id }}"
          S3_KEY="lambda-packages/${{ inputs.layer_name }}/layer-${{ github.sha }}.zip"

          echo "Bucket: ${ARTIFACTS_BUCKET}"
          echo "Key: ${S3_KEY}"

          # Upload to S3 with KMS encryption (required by bucket policy)
          aws s3 cp layer.zip "s3://${ARTIFACTS_BUCKET}/${S3_KEY}" \
            --sse aws:kms \
            --sse-kms-key-id ${{ inputs.kms_key_alias }} \
            --region ${{ inputs.aws_region }}

          echo "s3_bucket=${ARTIFACTS_BUCKET}" >> $GITHUB_ENV
          echo "s3_key=${S3_KEY}" >> $GITHUB_ENV

          echo "✅ Layer package uploaded to S3 with KMS encryption"

      - name: Check existing resources
        run: |
          echo "=== Checking Existing Resources ==="

          # Determine stack name
          if [ -n "${{ inputs.stack_name }}" ]; then
            STACK_NAME="${{ inputs.stack_name }}"
          else
            STACK_NAME="${{ inputs.layer_name }}-stack"
          fi

          # Check if stack exists
          if aws cloudformation describe-stacks --stack-name ${STACK_NAME} --region ${{ inputs.aws_region }} &>/dev/null; then
            echo "✅ Stack '${STACK_NAME}' exists - will be updated"
            aws cloudformation describe-stacks \
              --stack-name ${STACK_NAME} \
              --region ${{ inputs.aws_region }} \
              --query 'Stacks[0].{StackName:StackName,StackStatus:StackStatus,CreationTime:CreationTime}' \
              --output table
          else
            echo "ℹ️  Stack '${STACK_NAME}' does not exist - will be created"
          fi

          # Check if SSM parameter exists (if layer_name-latest pattern is used)
          SSM_PARAM_NAME="${{ inputs.layer_name }}-latest"
          if aws ssm get-parameter --name "${SSM_PARAM_NAME}" --region ${{ inputs.aws_region }} &>/dev/null 2>&1; then
            echo "✅ SSM parameter '${SSM_PARAM_NAME}' exists"
            CURRENT_ARN=$(aws ssm get-parameter \
              --name "${SSM_PARAM_NAME}" \
              --region ${{ inputs.aws_region }} \
              --query 'Parameter.Value' \
              --output text 2>/dev/null || echo "N/A")
            echo "   Current Layer ARN: ${CURRENT_ARN}"
          else
            echo "ℹ️  SSM parameter '${SSM_PARAM_NAME}' does not exist - will be created by SAM template"
          fi

      - name: Install SAM CLI
        run: |
          echo "=== Installing SAM CLI ==="
          # Ensure basic system PATH is available
          export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

          # Use python3 if python doesn't work, fallback to python
          if command -v python3 &> /dev/null && python3 -m pip --version &>/dev/null; then
            PYTHON_CMD="python3"
          elif command -v python &> /dev/null && python -m pip --version &>/dev/null; then
            PYTHON_CMD="python"
          else
            echo "Error: Neither python nor python3 with pip is available"
            exit 1
          fi

          # Create virtual environment to avoid externally-managed-environment error
          VENV_DIR="$HOME/venv"
          echo "Creating virtual environment at $VENV_DIR..."

          # Try to create venv with pip first
          if $PYTHON_CMD -m venv "$VENV_DIR" 2>/dev/null; then
            echo "Virtual environment created with pip"
          # If that fails, try without pip and install pip manually
          elif $PYTHON_CMD -m venv --without-pip "$VENV_DIR" 2>/dev/null; then
            echo "Virtual environment created without pip, installing pip..."
            # Install pip in the venv using get-pip.py
            /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
            if [ -f /tmp/get-pip.py ] && [ -f "$VENV_DIR/bin/python" ]; then
              "$VENV_DIR/bin/python" /tmp/get-pip.py 2>&1 || true
              /bin/rm -f /tmp/get-pip.py
            fi
          # If venv module doesn't work, try installing python3-venv
          else
            echo "venv module not available, trying to install python3-venv..."
            if command -v /usr/bin/apt-get &> /dev/null; then
              sudo /usr/bin/apt-get update && sudo /usr/bin/apt-get install -y python3-venv || true
              # Try again after installing python3-venv
              if $PYTHON_CMD -m venv "$VENV_DIR" 2>/dev/null; then
                echo "Virtual environment created after installing python3-venv"
              elif $PYTHON_CMD -m venv --without-pip "$VENV_DIR" 2>/dev/null; then
                echo "Virtual environment created without pip, installing pip..."
                /usr/bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || /bin/curl -sSL https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py || true
                if [ -f /tmp/get-pip.py ] && [ -f "$VENV_DIR/bin/python" ]; then
                  "$VENV_DIR/bin/python" /tmp/get-pip.py 2>&1 || true
                  /bin/rm -f /tmp/get-pip.py
                fi
              fi
            fi
          fi

          # Activate virtual environment if it exists and has pip
          if [ -f "$VENV_DIR/bin/activate" ] && [ -f "$VENV_DIR/bin/pip" ]; then
            source "$VENV_DIR/bin/activate"
            echo "$VENV_DIR/bin" >> $GITHUB_PATH
            export PATH="$VENV_DIR/bin:$PATH"
            echo "Virtual environment activated with pip"
            PIP_CMD="pip"
          elif [ -f "$VENV_DIR/bin/activate" ]; then
            # Venv exists but no pip - try to use system pip with --user
            echo "Warning: Virtual environment created but pip not available, using --user flag"
            export PATH="$HOME/.local/bin:$PATH"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
            PIP_CMD="$PYTHON_CMD -m pip"
            PIP_FLAG="--user"
          else
            echo "Warning: Virtual environment not created, using --user flag as fallback"
            export PATH="$HOME/.local/bin:$PATH"
            echo "$HOME/.local/bin" >> $GITHUB_PATH
            PIP_CMD="$PYTHON_CMD -m pip"
            PIP_FLAG="--user"
          fi

          # Install SAM CLI
          $PIP_CMD install $PIP_FLAG aws-sam-cli
          sam --version

      - name: Deploy Lambda Layer with SAM
        id: deploy
        run: |
          echo "=== Deploying Lambda Layer with SAM ==="

          # Determine stack name
          if [ -n "${{ inputs.stack_name }}" ]; then
            STACK_NAME="${{ inputs.stack_name }}"
          else
            STACK_NAME="${{ inputs.layer_name }}-stack"
          fi

          echo "Stack Name: ${STACK_NAME}"
          echo "Template: ${{ inputs.sam_template }}"

          # Verify template exists
          if [ ! -f "${{ inputs.sam_template }}" ]; then
            echo "❌ Error: SAM template not found: ${{ inputs.sam_template }}"
            exit 1
          fi

          # Deploy using SAM (matches GitLab CI/CD approach)
          sam deploy \
            --template-file ${{ inputs.sam_template }} \
            --stack-name ${STACK_NAME} \
            --parameter-overrides \
              ARTIFACTSBUCKET=${{ env.s3_bucket }} \
              S3Key=${{ env.s3_key }} \
              ACCOUNTID=${{ secrets.aws_account_id }} \
              NAME=${{ inputs.layer_name }} \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset \
            --region ${{ inputs.aws_region }}

          echo "stack_name=${STACK_NAME}" >> $GITHUB_ENV
          echo "✅ SAM deployment completed"

      - name: Get Layer Version ARN
        id: layer
        run: |
          echo "=== Getting Layer Version ARN ==="

          STACK_NAME="${{ env.stack_name }}"

          # Get layer ARN from CloudFormation stack outputs
          LAYER_ARN=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --region ${{ inputs.aws_region }} \
            --query 'Stacks[0].Outputs[?OutputKey==`LayerVersionArn`].OutputValue' \
            --output text 2>/dev/null || echo "")

          if [ -z "${LAYER_ARN}" ]; then
            # Try to get from SSM parameter (as defined in template)
            SSM_PARAM_NAME="${{ inputs.layer_name }}-latest"
            LAYER_ARN=$(aws ssm get-parameter \
              --name "${SSM_PARAM_NAME}" \
              --region ${{ inputs.aws_region }} \
              --query 'Parameter.Value' \
              --output text 2>/dev/null || echo "")
          fi

          if [ -n "${LAYER_ARN}" ]; then
            echo "Layer Version ARN: ${LAYER_ARN}"
            echo "layer_arn=${LAYER_ARN}" >> $GITHUB_OUTPUT
          else
            echo "⚠️  Warning: Could not retrieve layer ARN"
          fi

      - name: Verify deployment
        run: |
          echo "=== Verifying Layer Deployment ==="

          STACK_NAME="${{ env.stack_name }}"

          # Get stack status
          aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --region ${{ inputs.aws_region }} \
            --query 'Stacks[0].{StackName:StackName,StackStatus:StackStatus}' \
            --output table

          echo "✅ Layer deployment verified"
