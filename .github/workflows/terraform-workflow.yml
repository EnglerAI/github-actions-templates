name: Terraform Workflow

on:
  workflow_call:
    inputs:
      terraform_version:
        description: "Terraform version"
        required: false
        type: string
        default: "1.12.2"
      terraform_directory:
        description: "Terraform working directory"
        required: false
        type: string
        default: "terraform"
      environment:
        description: "Target environment (dev/qat/stg/prd)"
        required: true
        type: string
      aws_region:
        description: "AWS region"
        required: true
        type: string
        default: "us-east-2"
      state_bucket:
        description: "S3 bucket for Terraform state"
        required: true
        type: string
      state_key:
        description: "S3 key for Terraform state"
        required: true
        type: string
      state_table:
        description: "DynamoDB table for state locking"
        required: false
        type: string
        default: ""
      auto_apply:
        description: "Automatically apply changes (only for non-prod)"
        required: false
        type: boolean
        default: false
    secrets:
      aws_role_arn:
        description: "AWS IAM role ARN for OIDC"
        required: true

jobs:
  validate:
    runs-on: ubuntu-latest
    env:
      HOME: ${{ github.workspace }}/.home
    permissions:
      contents: read
      pull-requests: write # For PR comments

    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform_version }}

      - name: Terraform Format Check
        id: fmt
        working-directory: ${{ inputs.terraform_directory }}
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init (no backend)
        working-directory: ${{ inputs.terraform_directory }}
        run: terraform init -backend=false

      - name: Terraform Validate
        id: validate
        working-directory: ${{ inputs.terraform_directory }}
        run: terraform validate -no-color

      - name: Comment on PR (validation results)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          FMT_OUTCOME: ${{ steps.fmt.outcome }}
          VALIDATE_OUTCOME: ${{ steps.validate.outcome }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`

            <details><summary>Show Validation Output</summary>

            \`\`\`
            ${{ steps.validate.outputs.stdout }}
            \`\`\`

            </details>

            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Workflow: \`${{ github.workflow }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  plan:
    needs: [validate]
    if: github.event_name == 'pull_request' || github.ref_name != github.event.repository.default_branch
    runs-on: ubuntu-latest
    env:
      HOME: ${{ github.workspace }}/.home
    permissions:
      id-token: write
      contents: read
      pull-requests: write

    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform_version }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.aws_role_arn }}
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-terraform-plan

      - name: Terraform Init
        working-directory: ${{ inputs.terraform_directory }}
        run: |
          terraform init \
            -backend-config="bucket=${{ inputs.state_bucket }}" \
            -backend-config="key=${{ inputs.state_key }}" \
            -backend-config="region=${{ inputs.aws_region }}" \
            ${{ inputs.state_table != '' && format('-backend-config="dynamodb_table={0}"', inputs.state_table) || '' }} \
            -backend-config="encrypt=true"

      - name: Terraform Plan
        id: plan
        working-directory: ${{ inputs.terraform_directory }}
        run: |
          terraform plan -no-color -out=tfplan
          terraform show -no-color tfplan > plan.txt
        continue-on-error: true

      - name: Upload plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-${{ inputs.environment }}
          path: |
            ${{ inputs.terraform_directory }}/tfplan
            ${{ inputs.terraform_directory }}/plan.txt
          retention-days: 7

      - name: Comment on PR (plan results)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          PLAN_OUTCOME: ${{ steps.plan.outcome }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const planPath = '${{ inputs.terraform_directory }}/plan.txt';
            let plan = 'Plan file not found';

            try {
              plan = fs.readFileSync(planPath, 'utf8');
              // Truncate if too long
              if (plan.length > 60000) {
                plan = plan.substring(0, 60000) + '\n\n... (plan truncated)';
              }
            } catch (err) {
              plan = 'Error reading plan file: ' + err.message;
            }

            const output = `#### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`

            <details><summary>Show Plan</summary>

            \`\`\`terraform
            ${plan}
            \`\`\`

            </details>

            **Environment:** \`${{ inputs.environment }}\`
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Workflow: \`${{ github.workflow }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: Fail if plan failed
        if: steps.plan.outcome == 'failure'
        run: exit 1

  apply:
    needs: [validate]
    if: |
      github.event_name == 'push' && 
      (github.ref_name == 'main' || startsWith(github.ref_name, 'env/'))
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}
      url: https://console.aws.amazon.com/console/home?region=${{ inputs.aws_region }}
    permissions:
      id-token: write
      contents: read
    env:
      HOME: ${{ github.workspace }}/.home

    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform_version }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.aws_role_arn }}
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-terraform-apply

      - name: Terraform Init
        working-directory: ${{ inputs.terraform_directory }}
        run: |
          terraform init \
            -backend-config="bucket=${{ inputs.state_bucket }}" \
            -backend-config="key=${{ inputs.state_key }}" \
            -backend-config="region=${{ inputs.aws_region }}" \
            ${{ inputs.state_table != '' && format('-backend-config="dynamodb_table={0}"', inputs.state_table) || '' }} \
            -backend-config="encrypt=true"

      - name: Terraform Plan
        id: plan
        working-directory: ${{ inputs.terraform_directory }}
        run: |
          terraform plan -no-color -out=tfplan
          terraform show -no-color tfplan

      - name: Terraform Apply
        working-directory: ${{ inputs.terraform_directory }}
        run: |
          # For production, require manual approval (GitHub environment protection)
          # For non-prod with auto_apply, apply automatically
          if [[ "${{ inputs.environment }}" == "prd" ]] || [[ "${{ inputs.auto_apply }}" == "false" ]]; then
            echo "Manual approval required - using GitHub environment protection"
          fi

          terraform apply -auto-approve tfplan

      - name: Terraform Output
        id: output
        working-directory: ${{ inputs.terraform_directory }}
        run: |
          terraform output -json > outputs.json
          cat outputs.json

      - name: Upload outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-${{ inputs.environment }}
          path: ${{ inputs.terraform_directory }}/outputs.json
          retention-days: 30

  drift-detection:
    needs: [apply]
    if: |
      always() && 
      needs.apply.result == 'success' &&
      github.event_name == 'push'
    runs-on: ubuntu-latest
    env:
      HOME: ${{ github.workspace }}/.home
    permissions:
      id-token: write
      contents: read
      issues: write

    steps:
      - name: Configure Git (for self-hosted runners)
        run: |
          mkdir -p "$HOME"
          git config --global --add safe.directory '*' || true
          git config --global user.name "GitHub Actions" || true
          git config --global user.email "actions@github.com" || true
        continue-on-error: true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ inputs.terraform_version }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.aws_role_arn }}
          aws-region: ${{ inputs.aws_region }}
          role-session-name: github-actions-drift-detection

      - name: Terraform Init
        working-directory: ${{ inputs.terraform_directory }}
        run: |
          terraform init \
            -backend-config="bucket=${{ inputs.state_bucket }}" \
            -backend-config="key=${{ inputs.state_key }}" \
            -backend-config="region=${{ inputs.aws_region }}" \
            ${{ inputs.state_table != '' && format('-backend-config="dynamodb_table={0}"', inputs.state_table) || '' }} \
            -backend-config="encrypt=true"

      - name: Refresh State
        working-directory: ${{ inputs.terraform_directory }}
        run: terraform refresh -no-color
        continue-on-error: true

      - name: Detect Drift
        id: drift
        working-directory: ${{ inputs.terraform_directory }}
        run: |
          set +e
          terraform plan -detailed-exitcode -no-color > drift-plan.txt
          DRIFT_STATUS=$?
          set -e

          echo "drift_status=${DRIFT_STATUS}" >> $GITHUB_OUTPUT

          if [ $DRIFT_STATUS -eq 0 ]; then
            echo "‚úÖ No drift detected"
            echo "drift_detected=false" >> $GITHUB_OUTPUT
          elif [ $DRIFT_STATUS -eq 2 ]; then
            echo "‚ö†Ô∏è  Drift detected"
            echo "drift_detected=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Error detecting drift"
            echo "drift_detected=error" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Create drift issue
        if: steps.drift.outputs.drift_detected == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const driftPlan = fs.readFileSync('${{ inputs.terraform_directory }}/drift-plan.txt', 'utf8');

            const issueBody = `## ‚ö†Ô∏è Terraform State Drift Detected

            **Environment:** \`${{ inputs.environment }}\`
            **Detection Time:** ${new Date().toISOString()}
            **Branch:** \`${{ github.ref_name }}\`
            **Commit:** \`${{ github.sha }}\`

            ### What This Means
            The actual infrastructure state differs from what Terraform expects. This usually means:
            1. Infrastructure was changed outside of Terraform
            2. State file is out of sync
            3. Code was updated but not yet applied

            ### Drift Details

            <details><summary>Show Drift</summary>

            \`\`\`terraform
            ${driftPlan.length > 60000 ? driftPlan.substring(0, 60000) + '\n... (truncated)' : driftPlan}
            \`\`\`

            </details>

            ### Recommended Actions
            1. Review the drift details above
            2. Run \`terraform plan\` locally to see changes
            3. Run \`terraform apply\` to sync state with infrastructure
            4. Investigate why infrastructure was changed outside Terraform

            *This issue was automatically created by the drift detection workflow.*`;

            // Check if drift issue already exists
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: ['terraform-drift', '${{ inputs.environment }}']
            });

            if (issues.data.length === 0) {
              // Create new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üö® Terraform Drift Detected - ${{ inputs.environment }}`,
                body: issueBody,
                labels: ['terraform-drift', '${{ inputs.environment }}', 'infrastructure']
              });
            } else {
              // Update existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: issueBody
              });
            }
